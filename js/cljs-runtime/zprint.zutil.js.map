{"version":3,"sources":["zprint/zutil.cljc"],"mappings":"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","names":["zprint.zutil/down*","clojure.zip/down","zprint.zutil/up*","clojure.zip/up","zprint.zutil/right*","clojure.zip/right","zprint.zutil/left*","clojure.zip/left","zprint.zutil/next*","clojure.zip/next","zprint.zutil/prev*","clojure.zip/prev","zprint.zutil/replace*","clojure.zip/replace","zprint.zutil/insert-right*","clojure.zip/insert-right","zprint.zutil/edn*","rewrite-clj.zip.base/edn*","zprint.zutil/sexpr","rewrite-clj.zip.base/sexpr","zprint.zutil/string","rewrite-clj.zip.base/string","zprint.zutil/tag","rewrite-clj.zip.base/tag","zprint.zutil/skip","rewrite-clj.zip.whitespace/skip","zprint.zutil/whitespace?","zloc","cljs.core._EQ_","var_args","G__37191","zprint.zutil/skip-whitespace","js/Error","zprint.zutil.skip_whitespace","rewrite-clj.zip/right","f","zprint.zutil/whitespace-not-newline?","zprint.zutil/whitespace-or-comment?","rewrite-clj.zip.whitespace/whitespace-or-comment?","zprint.zutil/length","rewrite-clj.zip.base/length","zprint.zutil/rightmost?","rewrite-clj.zip.move/rightmost?","zprint.zutil/leftmost?","rewrite-clj.zip.move/leftmost?","zprint.zutil/zremove","rewrite-clj.zip.removez/remove","zprint.zutil/zreplace","rewrite-clj.zip.editz/replace","zprint.zutil/zfocus","floc","vec__37193","cljs.core.nth","_","zpath","zprint.zutil/find-root-and-path","zprint.zutil/zfocus-style","style","zprint.zutil/z-coll?","rewrite-clj.zip/seq?","zprint.zutil/zuneval?","zprint.zutil/zmeta?","zprint.zutil/zquote?","zprint.zutil/zreader-macro?","zprint.zutil/ztag","zprint.zutil/znamespacedmap?","or__4126__auto__","cljs.core/re-find","rewrite-clj.zip/string","zprint.zutil/zcomment?","zprint.zutil/znewline?","zprint.zutil/znumstr","zprint.zutil/zstart","zprint.zutil/zfirst","nloc","zprint.zutil/zfirst-no-comment","zprint.zutil/zsecond","temp__5733__auto__","first-loc","zprint.zutil/zsecond-no-comment","zprint.zutil/zthird","G__37206","zprint.zutil/zthird-no-comment","G__37207","zprint.zutil/zfourth","G__37211","zprint.zutil/zrightnws","zprint.zutil/znextnws-w-nl","zprint.zutil/zrightmost","ploc","cljs.core/not","zprint.zutil/zleftnws","zprint.zutil/zleftmost","zprint.zutil/zprevnws","zprint.zutil/znthnext","n","i","zprint.zutil/zfind","zthing?","zprint.zutil/znl","G__37224","rewrite-clj.parser/parse-string","zprint.zutil/multi-nl","cljs.core.apply","cljs.core/vector","cljs.core.repeat","zprint.zutil/split-newline-from-comment","comment-no-nl","clojure.string/replace-first","new-comment","G__37226","G__37227","zprint.zutil/zmap-w-bl","zfn","blank?","previous-was-nl?","previous-comment?","out","ws?","nl?","rewrite-clj.zip/tag","nl-len","multi-nl?","emit-nl?","nl-to-emit","cljs.core.mapv","comment?","result","cljs.core.conj","cljs.core/conj","zprint.zutil/zmap-w-nl","zprint.zutil/zmap-w-nl-comma","comma?","clojure.string/includes?","zprint.zutil/zmap","zprint.zutil/zmap-alt","zprint.zutil/zcount","zprint.zutil/zmap-all","zprint.zutil/zseqnws","cljs.core/identity","zprint.zutil/zseqnws-w-nl","zprint.zutil/zseqnws-w-bl","zprint.zutil/zremove-right","G__37256","zprint.zutil/ztake-append","end-struct","index","G__37257","xloc","zprint.zutil/zcount-zloc-seq-nc-nws","zloc-seq","p1__37259#","p2__37258#","cljs.core.reduce","left","cljs.core/cons","zprint.zutil/find-root-and-path-nw","zprint.zutil/find-root","rewrite-clj.zip/up","zprint.zutil/move-down-and-right","right-count","remaining-right","zprint.zutil/follow-path","path-vec","zprint.zutil/zanonfn?","zprint.zutil/zlast","zprint.zutil/zsexpr?","and__4115__auto__","cljs.core.not_EQ_","G__37269","rewrite-clj.node/printable-only?","rewrite-clj.zip/node","zprint.zutil/zkeyword?","clojure.string/starts-with?","zprint.zutil/zsymbol?","cljs.core/Symbol","zprint.zutil/znil?","rewrite-clj.zip/sexpr","zprint.zutil/zreader-cond-w-symbol?","element","rewrite-clj.zip/down","G__37280","zprint.zutil/zreader-cond-w-coll?","G__37413","zprint.zutil/zdotdotdot","G__37418","zprint.zutil/zconstant?","ztag","G__37420","sexpr","zprint.zutil/find-doc-in-map","G__37424","G__37425","zprint.zutil/find-docstring","fn-name","G__37427","docloc","G__37428","G__37429","maploc","G__37431","G__37432","rewrite-clj.zip/map?","zprint.zutil/add-spec-to-docstring","spec-str","doc-zloc","new-doc-zloc","G__37433","G__37434","G__37435","G__37436","G__37437","rewrite-clj.zip/root","p__37444","map__37445","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get","zprint.zutil/zlift-ns","in-code?","lift-ns?","lift-ns-in-code?","unlift-ns?","map-options","pair-seq","ns","strip-ns","named","cljs.core.symbol","cljs.core/name","cljs.core.keyword","vec__37457","seq__37458","cljs.core/seq","first__37459","cljs.core/first","cljs.core/next","k","rest-of-pair","pair","current-ns","cljs.core/namespace","G__37469","G__37470","rewrite-clj.node/token-node","G__37471","G__37472","cljs.core/count","vec__37483","seq__37484","first__37485","G__37486","G__37487","zprint.zutil/zredef-call","body-fn","zstring-orig-val__37489","znumstr-orig-val__37490","zbyte-array?-orig-val__37491","zcomment?-orig-val__37492","zsexpr-orig-val__37493","zseqnws-orig-val__37494","zseqnws-w-nl-orig-val__37495","zseqnws-w-bl-orig-val__37496","zfocus-style-orig-val__37497","zstart-orig-val__37498","zfirst-orig-val__37499","zfirst-no-comment-orig-val__37500","zsecond-orig-val__37501","zsecond-no-comment-orig-val__37502","zthird-orig-val__37503","zthird-no-comment-orig-val__37504","zfourth-orig-val__37505","znextnws-orig-val__37506","znextnws-w-nl-orig-val__37507","znthnext-orig-val__37508","zcount-orig-val__37509","zcount-zloc-seq-nc-nws-orig-val__37510","zmap-orig-val__37511","zmap-w-nl-orig-val__37512","zmap-w-bl-orig-val__37513","zmap-w-nl-comma-orig-val__37514","zanonfn?-orig-val__37515","zfn-obj?-orig-val__37516","zfocus-orig-val__37517","zfind-path-orig-val__37518","zwhitespace?-orig-val__37519","zlist?-orig-val__37520","zvector?-orig-val__37521","zmap?-orig-val__37522","znamespacedmap?-orig-val__37523","zset?-orig-val__37524","zcoll?-orig-val__37525","zuneval?-orig-val__37526","zmeta?-orig-val__37527","ztag-orig-val__37528","zlast-orig-val__37529","zarray?-orig-val__37530","zatom?-orig-val__37531","zderef-orig-val__37532","zrecord?-orig-val__37533","zns?-orig-val__37534","zobj-to-vec-orig-val__37535","zexpandarray-orig-val__37536","znewline?-orig-val__37537","zwhitespaceorcomment?-orig-val__37538","zmap-all-orig-val__37539","zpromise?-orig-val__37540","zfuture?-orig-val__37541","zdelay?-orig-val__37542","zkeyword?-orig-val__37543","zconstant?-orig-val__37544","zagent?-orig-val__37545","zreader-macro?-orig-val__37546","zarray-to-shift-seq-orig-val__37547","zdotdotdot-orig-val__37548","zsymbol?-orig-val__37549","znil?-orig-val__37550","zreader-cond-w-symbol?-orig-val__37551","zreader-cond-w-coll?-orig-val__37552","zlift-ns-orig-val__37553","zfind-orig-val__37554","ztake-append-orig-val__37555","zstring-temp-val__37556","znumstr-temp-val__37557","zbyte-array?-temp-val__37558","zcomment?-temp-val__37559","zsexpr-temp-val__37560","zseqnws-temp-val__37561","zseqnws-w-nl-temp-val__37562","zseqnws-w-bl-temp-val__37563","zfocus-style-temp-val__37564","zstart-temp-val__37565","zfirst-temp-val__37566","zfirst-no-comment-temp-val__37567","zsecond-temp-val__37568","zsecond-no-comment-temp-val__37569","zthird-temp-val__37570","zthird-no-comment-temp-val__37571","zfourth-temp-val__37572","znextnws-temp-val__37573","znextnws-w-nl-temp-val__37574","znthnext-temp-val__37575","zcount-temp-val__37576","zcount-zloc-seq-nc-nws-temp-val__37577","zmap-temp-val__37578","zmap-w-nl-temp-val__37579","zmap-w-bl-temp-val__37580","zmap-w-nl-comma-temp-val__37581","zanonfn?-temp-val__37582","zfn-obj?-temp-val__37583","zfocus-temp-val__37584","zfind-path-temp-val__37585","zwhitespace?-temp-val__37586","zlist?-temp-val__37587","zvector?-temp-val__37588","zmap?-temp-val__37589","znamespacedmap?-temp-val__37590","zset?-temp-val__37591","zcoll?-temp-val__37592","zuneval?-temp-val__37593","zmeta?-temp-val__37594","ztag-temp-val__37595","zlast-temp-val__37596","zarray?-temp-val__37597","zatom?-temp-val__37598","zderef-temp-val__37599","zrecord?-temp-val__37600","zns?-temp-val__37601","zobj-to-vec-temp-val__37602","zexpandarray-temp-val__37603","znewline?-temp-val__37604","zwhitespaceorcomment?-temp-val__37605","zmap-all-temp-val__37606","zpromise?-temp-val__37607","zfuture?-temp-val__37608","zdelay?-temp-val__37609","zkeyword?-temp-val__37610","zconstant?-temp-val__37611","zagent?-temp-val__37612","zreader-macro?-temp-val__37613","zarray-to-shift-seq-temp-val__37614","zdotdotdot-temp-val__37615","zsymbol?-temp-val__37616","znil?-temp-val__37617","zreader-cond-w-symbol?-temp-val__37618","zreader-cond-w-coll?-temp-val__37619","zlift-ns-temp-val__37620","zfind-temp-val__37621","ztake-append-temp-val__37622","zprint.zfns/zstring","zprint.zfns/znumstr","zprint.zfns/zbyte-array?","cljs.core/constantly","zprint.zfns/zcomment?","zprint.zfns/zsexpr","zprint.zfns/zseqnws","zprint.zfns/zseqnws-w-nl","zprint.zfns/zseqnws-w-bl","zprint.zfns/zfocus-style","zprint.zfns/zstart","zprint.zfns/zfirst","zprint.zfns/zfirst-no-comment","zprint.zfns/zsecond","zprint.zfns/zsecond-no-comment","zprint.zfns/zthird","zprint.zfns/zthird-no-comment","zprint.zfns/zfourth","zprint.zfns/znextnws","zprint.zfns/znextnws-w-nl","zprint.zfns/znthnext","zprint.zfns/zcount","zprint.zfns/zcount-zloc-seq-nc-nws","zprint.zfns/zmap","zprint.zfns/zmap-w-nl","zprint.zfns/zmap-w-bl","zprint.zfns/zmap-w-nl-comma","zprint.zfns/zanonfn?","zprint.zfns/zfn-obj?","zprint.zfns/zfocus","zprint.zfns/zfind-path","zprint.zfns/zwhitespace?","zprint.zfns/zlist?","rewrite-clj.zip/list?","zprint.zfns/zvector?","rewrite-clj.zip/vector?","zprint.zfns/zmap?","zprint.zfns/znamespacedmap?","zprint.zfns/zset?","rewrite-clj.zip/set?","zprint.zfns/zcoll?","zprint.zfns/zuneval?","zprint.zfns/zmeta?","zprint.zfns/ztag","zprint.zfns/zlast","zprint.zfns/zarray?","zprint.zfns/zatom?","zprint.zfns/zderef","zprint.zfns/zrecord?","zprint.zfns/zns?","zprint.zfns/zobj-to-vec","zprint.zfns/zexpandarray","zprint.zfns/znewline?","zprint.zfns/zwhitespaceorcomment?","zprint.zfns/zmap-all","zprint.zfns/zpromise?","zprint.zfns/zfuture?","zprint.zfns/zdelay?","zprint.zfns/zkeyword?","zprint.zfns/zconstant?","zprint.zfns/zagent?","zprint.zfns/zreader-macro?","zprint.zfns/zarray-to-shift-seq","zprint.zfns/zdotdotdot","zprint.zfns/zsymbol?","zprint.zfns/znil?","zprint.zfns/zreader-cond-w-symbol?","zprint.zfns/zreader-cond-w-coll?","zprint.zfns/zlift-ns","zprint.zfns/zfind","zprint.zfns/ztake-append"],"sourcesContent":["(ns ^:no-doc zprint.zutil\n  (:require\n    #?@(:clj [[zprint.macros :refer [do-redef-vars]]])\n    clojure.string\n    zprint.zfns\n    #?@(:clj [[zprint.redef]])\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.node :as n]\n    [rewrite-clj.zip :as z]\n    #?@(:cljs [[rewrite-clj.zip.base :as zb] [rewrite-clj.zip.whitespace :as zw]\n               [rewrite-clj.zip.move :as zm] [rewrite-clj.zip.removez :as zr]\n               [rewrite-clj.zip.editz :as ze] clojure.zip])))\n\n;;\n;; # Zipper oriented style printers\n;;\n\n;;\n;; Note that both rewrite-clj and rewrite-cljs use the following namespaces:\n;;\n;; rewrite-clj.parse\n;; rewrite-clj.node\n;; rewrite-clj.zip\n;;\n;; and have many common routines.  So it is fine to use z/<fn> as long as\n;; that <fn> shows up in both libraries.\n;;\n\n;;\n;; ## clj and cljs compatibility routines\n;;\n;; ### Routines missing in :cljs since it uses clojure.zip\n;; \n\n(def down*\n  #?(:clj z/down*\n     :cljs clojure.zip/down))\n\n(def up*\n  #?(:clj z/up*\n     :cljs clojure.zip/up))\n\n(def right*\n  #?(:clj z/right*\n     :cljs clojure.zip/right))\n\n(def left*\n  #?(:clj z/left*\n     :cljs clojure.zip/left))\n\n(def next*\n  #?(:clj z/next*\n     :cljs clojure.zip/next))\n\n(def prev*\n  #?(:clj z/prev*\n     :cljs clojure.zip/prev))\n\n(def replace*\n  #?(:clj z/replace*\n     :cljs clojure.zip/replace))\n\n(def insert-right*\n  #?(:clj z/insert-right*\n     :cljs clojure.zip/insert-right))\n\n;;\n;; ### Routines with different namespaces\n;;\n\n(def edn*\n  #?(:clj z/edn*\n     :cljs zb/edn*))\n\n(def sexpr\n  #?(:clj z/sexpr\n     :cljs zb/sexpr))\n\n(def string\n  #?(:clj z/string\n     :cljs zb/string))\n\n(def tag\n  #?(:clj z/tag\n     :cljs zb/tag))\n\n(def skip\n  #?(:clj z/skip\n     :cljs zw/skip))\n\n(defn whitespace?\n  [zloc]\n  (or (= (tag zloc) :whitespace) (= (tag zloc) :newline) (= (tag zloc) :comma)))\n\n; indent-only\n(defn skip-whitespace\n  ([zloc] (skip-whitespace z/right zloc))\n  ([f zloc] (skip f whitespace? zloc)))\n\n(defn whitespace-not-newline?\n  [zloc]\n  (or (= (tag zloc) :whitespace) (= (tag zloc) :comma)))\n\n(def whitespace-or-comment?\n  #?(:clj z/whitespace-or-comment?\n     :cljs zw/whitespace-or-comment?))\n\n(def length\n  #?(:clj z/length\n     :cljs zb/length))\n\n(def rightmost?\n  #?(:clj z/rightmost?\n     :cljs zm/rightmost?))\n\n(def leftmost?\n  #?(:clj z/leftmost?\n     :cljs zm/leftmost?))\n\n; conflicts with clojure.core:\n\n(def zremove\n  #?(:clj z/remove\n     :cljs zr/remove))\n\n(def zreplace\n  #?(:clj z/replace\n     :cljs ze/replace))\n\n;;\n;; Check to see if we are at the focus by checking the\n;; path.\n;;\n\n(declare find-root-and-path)\n\n(defn zfocus\n  \"Is the zipper zloc equivalent to the path floc.  In this\n  case, floc isn't a zipper, but was turned into a path early on.\"\n  [zloc floc]\n  (let [[_ zpath] (find-root-and-path zloc)] (= zpath floc)))\n\n(defn zfocus-style\n  \"Take the various inputs and come up with a style.\"\n  [style zloc floc]\n  (let [style (if (= style :f) style (if (zfocus zloc floc) :f :b))] style))\n\n(defn z-coll? \"Is the zloc a collection?\" [zloc] (z/seq? zloc))\n\n(defn zuneval? \"Is this a #_(...)\" [zloc] (= (tag zloc) :uneval))\n\n(defn zmeta? \"Is this a ^{...}\" [zloc] (= (tag zloc) :meta))\n\n(defn zquote?\n  \"Is this a '(...) or '[ ... ] or some other quote?\"\n  [zloc]\n  (= (tag zloc) :quote))\n\n(defn zreader-macro? \"Is this a @...\" [zloc] (= (tag zloc) :reader-macro))\n\n(defn ztag \"Return the tag for this zloc\" [zloc] (tag zloc))\n\n(defn znamespacedmap?\n  \"Is this a namespaced map?\"\n  [zloc]\n  #?(:clj (= (tag zloc) :namespaced-map)\n     :cljs (or (= (tag zloc) :namespaced-map)\n               (re-find #\"^#:\" (z/string zloc)))))\n\n(defn zcomment?\n  \"Returns true if this is a comment.\"\n  [zloc]\n  (when zloc (= (tag zloc) :comment)))\n\n(defn znewline?\n  \"Returns true if this is a newline.\"\n  [zloc]\n  (when zloc (= (tag zloc) :newline)))\n\n(defn znumstr\n  \"Does z/string, but takes an additional argument for hex conversion.\n  Hex conversion is not implemented for zippers, though, because at present\n  it is only used for byte-arrays, which don't really show up here.\"\n  [zloc _ _]\n  (string zloc))\n\n(defn zstart \"Find the zloc inside of this zloc.\" [zloc] (down* zloc))\n\n(defn zfirst\n  \"Find the first non-whitespace zloc inside of this zloc, or\n  the first whitespace zloc that is the focus.\"\n  [zloc]\n  (let [nloc (down* zloc)] (if nloc (skip right* whitespace? nloc))))\n\n(defn zfirst-no-comment\n  \"Find the first non-whitespace and non-comment zloc inside of this zloc.\"\n  [zloc]\n  (let [nloc (down* zloc)] (if nloc (skip right* whitespace-or-comment? nloc))))\n\n(defn zsecond\n  \"Find the second non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (if-let [first-loc (zfirst zloc)]\n    (if-let [nloc (right* first-loc)] (skip right* whitespace? nloc))))\n\n(defn zsecond-no-comment\n  \"Find the second non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (if-let [first-loc (zfirst-no-comment zloc)]\n    (if-let [nloc (right* first-loc)]\n      (skip right* whitespace-or-comment? nloc))))\n\n(defn zthird\n  \"Find the third non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (some->> (zfirst zloc)\n           right*\n           (skip right* whitespace?)\n           right*\n           (skip right* whitespace?)))\n\n(defn zthird-no-comment\n  \"Find the third non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (some->> (zfirst-no-comment zloc)\n           right*\n           (skip right* whitespace-or-comment?)\n           right*\n           (skip right* whitespace-or-comment?)))\n\n(defn zfourth\n  \"Find the fourth non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (some->> (zfirst zloc)\n           right*\n           (skip right* whitespace?)\n           right*\n           (skip right* whitespace?)\n           right*\n           (skip right* whitespace?)))\n\n(defn zrightnws\n  \"Find the next non-whitespace zloc inside of this zloc. Returns nil\n  if nothing left.\"\n  [zloc]\n  (if zloc (if-let [nloc (right* zloc)] (skip right* whitespace? nloc))))\n\n(defn znextnws-w-nl\n  \"Find the next non-whitespace zloc inside of this zloc considering \n  newlines to not be whitespace. Returns nil if nothing left. Which is\n  why this is nextnws and not rightnws, since it is exposed in zfns.\"\n  [zloc]\n  (if zloc\n    (if-let [nloc (right* zloc)] (skip right* whitespace-not-newline? nloc))))\n\n(defn zrightmost\n  \"Find the rightmost non-whitespace zloc at this level\"\n  [zloc]\n  (loop [nloc (zrightnws zloc)\n         ploc zloc]\n    (if-not nloc ploc (recur (zrightnws nloc) nloc))))\n\n(defn zleftnws\n  \"Find the next non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (if zloc (if-let [nloc (left* zloc)] (skip left* whitespace? nloc))))\n\n(defn zleftmost\n  \"Find the leftmost non-whitespace zloc at this level\"\n  [zloc]\n  (loop [nloc (zleftnws zloc)\n         ploc zloc]\n    (if-not nloc ploc (recur (zleftnws nloc) nloc))))\n\n; This uses next*, not right*, and will step up out of a sequence.\n#_(defn znextnws\n    \"Find the next non-whitespace zloc.\"\n    [zloc]\n    (if (z/end? zloc)\n      zloc\n      (if-let [nloc (next* zloc)] (skip next* whitespace? nloc))))\n\n(defn zprevnws\n  \"Find the next non-whitespace zloc.\"\n  [zloc]\n  (if-let [ploc (prev* zloc)] (skip prev* whitespace? ploc)))\n\n(defn znthnext\n  \"Find the nth non-whitespace zloc inside of this zloc.\"\n  [zloc n]\n  (loop [nloc (skip-whitespace (down* zloc))\n         i ^long n]\n    (if (or (nil? nloc) (= i 0)) nloc (recur (zrightnws nloc) (dec i)))))\n\n(defn zfind\n  \"Find the locations (counting from zero, and only counting non-whitespace\n  elements) of the first zthing?.  Return its index if it is found, nil if not.\"\n  [zthing? zloc]\n  (loop [nloc (skip-whitespace (down* zloc))\n         i 0]\n    (when (not (nil? nloc))\n      (if (zthing? nloc) i (recur (zrightnws nloc) (inc i))))))\n\n(defn znl [] \"Return a zloc which is a newline.\" (edn* (p/parse-string \"\\n\")))\n\n(defn multi-nl\n  \"Return a sequence of zloc newlines.\"\n  [n]\n  (apply vector (repeat n (znl))))\n\n(defn split-newline-from-comment\n  \"Given a zloc which is a comment, replace it with a zloc which is the\n  same comment with no newline, and a newline that follows it.  This is\n  done in the zipper so that later navigation in this area remains\n  continues to work.\"\n  [zloc]\n  (let [comment-no-nl (p/parse-string\n                        (clojure.string/replace-first (z/string zloc) \"\\n\" \"\"))\n        new-comment (replace* zloc comment-no-nl)\n        new-comment (insert-right* new-comment (p/parse-string \"\\n\"))]\n    new-comment))\n\n(defn zmap-w-bl\n  \"Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including two newlines\n  for every blank line encountered.  Note that a truly blank line\n  will show up as one zloc with two newlines in it.  It will have\n  (= (z/tag nloc) :newline), but it will have both newlines.  To\n  ease handling of these multi-line newlines, this routine will\n  split them up into multiple individual newlines.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         blank? false\n         previous-was-nl? false\n         previous-comment? nil\n         out []]\n    (if-not nloc\n      out\n      (let [ws? (whitespace? nloc)\n            nl? (= (z/tag nloc) :newline)\n            nl-len (when nl? (length nloc))\n            multi-nl? (when nl? (> (length nloc) 1))\n            emit-nl? (or (and blank? nl?) multi-nl?)\n            ; newline thing to emit\n            nl-to-emit (when emit-nl?\n                         (cond multi-nl? (mapv zfn\n                                           (multi-nl (if (or previous-was-nl?\n                                                             (not blank?))\n                                                       nl-len\n                                                       (inc nl-len))))\n                               previous-was-nl? [(zfn nloc)]\n                               :else [(zfn nloc) (zfn nloc)]))\n            ; non newline thing to emit\n            comment? (= (z/tag nloc) :comment)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (or (not ws?) (and nl? previous-comment?)) (zfn nloc))]\n        #_(prn \"map-w-bl: blank?\" blank?\n               \", zloc:\" (z/string nloc)\n               \", length:\" (length nloc)\n               \", ws?\" ws?\n               \", previous-was-nl??\" previous-was-nl?\n               \", previous-comment?\" previous-comment?\n               \", nl? \" nl?\n               \", nl-len:\" nl-len\n               \", multi-nl?\" multi-nl?\n               \", emit-nl?\" emit-nl?\n               \", nl-to-emit\" (map z/string nl-to-emit))\n        (recur (right* nloc)\n               (if blank?\n                 ; If already blank, then if it is whitespace it is still\n                 ; blank.  That includes newlines (which are ws? too).\n                 (or ws? nl?)\n                 ; Not already blank, only a newline (of any length)\n                 ; will start blank\n                 nl?)\n               ; If we emitted something, was it a nl?  If nothing emitted,\n               ; no change.\n               (if (or result nl-to-emit)\n                 ; Two ways to emit a nl\n                 (or (and nl? previous-comment?) emit-nl?)\n                 previous-was-nl?)\n               comment?\n               (cond result (conj out result)\n                     nl-to-emit (apply conj out nl-to-emit)\n                     :else out))))))\n\n(defn zmap-w-nl\n  \"Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment. The\n  comment split actually changes the zipper for the rest of the\n  sequence, where the newline splits do not.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         out []]\n    (if-not nloc\n      out\n      (let [; non-newline thing to emit\n            nl? (= (z/tag nloc) :newline)\n            comment? (= (z/tag nloc) :comment)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (not (whitespace? nloc)) (zfn nloc))\n            nl-len (when nl? (length nloc))\n            multi-nl? (when nl? (> (length nloc) 1))\n            ; newline thing to emit\n            nl-to-emit\n              (when nl?\n                (if multi-nl? (mapv zfn (multi-nl nl-len)) [(zfn nloc)]))]\n        #_(println \"zmap-w-nl: tag:\" (z/tag nloc))\n        (recur (right* nloc)\n               (cond result (conj out result)\n                     nl-to-emit (apply conj out nl-to-emit)\n                     :else out))))))\n\n(defn zmap-w-nl-comma\n  \"Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines and commas.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         out []]\n    (if-not nloc\n      out\n      (let [; non-newline thing to emit\n            nl? (= (z/tag nloc) :newline)\n            comma? #?(:clj (= (z/tag nloc) :comma)\n                      :cljs (or (= (z/tag nloc) :comma)\n                                (and (= (z/tag nloc) :whitespace)\n                                     (clojure.string/includes? (z/string nloc)\n                                                               \",\"))))\n            comment? (= (z/tag nloc) :comment)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (or (not (whitespace? nloc)) comma?) (zfn nloc))\n            nl-len (when nl? (length nloc))\n            multi-nl? (when nl? (> (length nloc) 1))\n            ; newline thing to emit\n            nl-to-emit\n              (when nl?\n                (if multi-nl? (mapv zfn (multi-nl nl-len)) [(zfn nloc)]))]\n        #_(prn \"zmap-w-nl-comma: tag:\" (z/tag nloc) (z/string nloc))\n        (recur (right* nloc)\n               (cond result (conj out result)\n                     nl-to-emit (apply conj out nl-to-emit)\n                     :else out))))))\n\n(defn zmap\n  \"Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc. The newline that shows\n  up in every comment is also split out into a separate zloc.\"\n  [zfn zloc]\n  #_(prn \"zmap: zloc\" (z/string zloc))\n  (loop [nloc (down* zloc)\n         previous-comment? nil\n         out []]\n    (if-not nloc\n      out\n      (let [comment? (= (z/tag nloc) :comment)\n            nl? (= (z/tag nloc) :newline)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (or (not (whitespace? nloc))\n                             (and nl? previous-comment?))\n                     (zfn nloc))]\n        (recur (right* nloc) comment? (if result (conj out result) out))))))\n\n; This was the original zmap before all of the changes...\n(defn zmap-alt\n  \"Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         out []]\n    (if-not nloc\n      out\n      (recur (right* nloc)\n             (if-let [result (when (not (whitespace? nloc)) (zfn nloc))]\n               (conj out result)\n               out)))))\n\n(defn zcount\n  \"Return the count of non-whitespace elements in zloc.  Comments are\n  counted as one thing, commas are ignored as whitespace.\"\n  [zloc]\n  (loop [nloc (down* zloc)\n         i 0]\n    (if-not nloc\n      i\n      (recur (right* nloc) (if (not (whitespace? nloc)) (inc i) i)))))\n\n; Used in core.cljc\n(defn zmap-all\n  \"Return a vector containing the return of applying a function to \n  every zloc inside of zloc.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         out []]\n    (if-not nloc out (recur (right* nloc) (conj out (zfn nloc))))))\n\n(defn zseqnws\n  \"Return a seq of all of the non-whitespace children of zloc.\"\n  [zloc]\n  (zmap identity zloc))\n\n(defn zseqnws-w-nl\n  \"Return a seq of all of the non-whitespace children of zloc, including\n  newlines.\"\n  [zloc]\n  (zmap-w-nl identity zloc))\n\n(defn zseqnws-w-bl\n  \"Return a seq of all of the non-whitespace children of zloc, including\n  only newlines that start and end blank lines.\"\n  [zloc]\n  (zmap-w-bl identity zloc))\n\n(defn zremove-right\n  \"Remove everything to the right of the current zloc. In other words,\n  make the current zloc the rightmost.\"\n  [zloc]\n  (loop [nloc zloc]\n    (if (rightmost? nloc) nloc (recur (zremove (right* nloc))))))\n\n(defn ztake-append\n  \"Considering the current zloc a collection, move down into it and\n  take n non-whitespace elements, dropping the rest.  Then append the\n  given element to the end, coercing it into a node/zloc.  Note, this \n  is not quite implemented that way, as it uses replace.\"\n  [n zloc end-struct]\n  (loop [nloc (down* zloc)\n         index 0]\n    (if (>= index n)\n      (up* (zremove-right (zreplace nloc end-struct)))\n      (let [xloc (right* nloc)]\n        (recur xloc (if (whitespace? xloc) index (inc index)))))))\n\n(defn zcount-zloc-seq-nc-nws\n  \"How many non-whitespace non-comment children are in zloc-seq? Note\n  that this is fundamentally different from zcount, in that it doesn't\n  take a zloc, but rather a zloc-seq (i.e., a seq of elements, each of\n  which is a zloc).\"\n  [zloc-seq]\n  (reduce #(if (whitespace-or-comment? %2) %1 (inc %1)) 0 zloc-seq))\n\n(defn find-root-and-path\n  \"Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves include\n  both whitespace and comments.\"\n  [zloc]\n  (if zloc\n    (loop [nloc zloc\n           left 0\n           out ()]\n      (if-not (left* nloc)\n        (if-not (up* nloc) [nloc out] (recur (up* nloc) 0 (cons left out)))\n        (recur (left* nloc) (inc left) out)))))\n\n(defn find-root-and-path-nw\n  \"Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves are\n  non-whitespace, but include comments.\"\n  [zloc]\n  (if zloc\n    (loop [nloc zloc\n           left 0\n           out ()]\n      (if-not (left* nloc)\n        (if-not (up* nloc) [nloc out] (recur (up* nloc) 0 (cons left out)))\n        (recur (left* nloc) (if (whitespace? nloc) left (inc left)) out)))))\n\n(defn find-root\n  \"Find the root from a zloc by doing lots of ups.\"\n  [zloc]\n  (loop [nloc zloc] (if-not (z/up nloc) nloc (recur (z/up nloc)))))\n\n(defn move-down-and-right\n  \"Move one down and then right a certain number of steps.\"\n  [zloc ^long right-count]\n  (loop [nloc (down* zloc)\n         remaining-right right-count]\n    (if (zero? remaining-right)\n      nloc\n      (recur (right* nloc) (dec remaining-right)))))\n\n(defn follow-path\n  \"Follow the path vector from the root and return the zloc\n  at this location.\"\n  [path-vec zloc]\n  (reduce move-down-and-right zloc path-vec))\n\n(defn zanonfn? \"Is this an anonymous fn?\" [zloc] (= (tag zloc) :fn))\n\n(defn zlast\n  \"Return the last non-whitespace (but possibly comment) element inside\n  of this zloc.\"\n  [zloc]\n  (let [nloc (down* zloc)] (when nloc (zrightmost nloc))))\n\n(defn zsexpr?\n  \"Returns true if this can be converted to an sexpr. Works around a bug\n  where n/printable-only? returns false for n/tag :fn, but z/sexpr fails\n  on something with n/tag :fn\"\n  [zloc]\n  (and zloc (not= :fn (tag zloc)) (not (n/printable-only? (z/node zloc)))))\n\n;\n; This doesn't work, because there are situations where (zsexpr? zloc)\n; will fail but it is still a keyword.\n;\n#_(defn zkeyword?-alt\n    \"Returns true if this is a keyword.\"\n    [zloc]\n    (and zloc (zsexpr? zloc) (keyword? (sexpr zloc))))\n\n(defn zkeyword?\n  \"Returns true if this is a keyword.\"\n  [zloc]\n  (and zloc (clojure.string/starts-with? (z/string zloc) \":\")))\n\n(defn zsymbol?\n  \"Returns true if this is a symbol.\"\n  [zloc]\n  (and zloc (zsexpr? zloc) (symbol? (sexpr zloc))))\n\n(defn znil?\n  \"Returns true if this is nil.\"\n  [zloc]\n  (and zloc (zsexpr? zloc) (nil? (z/sexpr zloc))))\n\n(defn zreader-cond-w-symbol?\n  \"Returns true if this is a reader-conditional with a symbol in \n  the first position (could be :clj or :cljs, whatever).\"\n  [zloc]\n  (let [result (when (zreader-macro? zloc)\n                 (let [element (z/down zloc)]\n                   (when (= (z/string element) \"?\")\n                     (let [element (z/down (z/right element))]\n                       (when (or (= (z/string element) \":clj\")\n                                 (= (z/string element) \":cljs\"))\n                         (zsymbol? (z/right element)))))))]\n    #_(println \"zreader-cond-w-symbol?:\" (z/string zloc) \"result:\" result)\n    result))\n\n(defn zreader-cond-w-coll?\n  \"Returns true if this is a reader-conditional with a collection in \n  the first position (could be :clj or :cljs, whatever).\"\n  [zloc]\n  (let [result (when (zreader-macro? zloc)\n                 (let [element (z/down zloc)]\n                   (when (= (z/string element) \"?\")\n                     (let [element (z/down (z/right element))]\n                       (when (or (= (z/string element) \":clj\")\n                                 (= (z/string element) \":cljs\"))\n                         (z-coll? (z/right element)))))))]\n    #_(println \"zreader-cond-w-coll?:\" (z/string zloc) \"result:\" result)\n    result))\n\n(defn zdotdotdot\n  \"Return a zloc that will turn into a string of three dots.\"\n  []\n  (edn* (p/parse-string \"...\")))\n\n(defn zconstant?\n  \"Returns true if this is a keyword, string, or number, in other words,\n  a constant.\"\n  [zloc]\n  #_(println \"zconstant?\" (z/string zloc))\n  (let [ztag (z/tag zloc)]\n    (if (or (= ztag :unquote) (= ztag :quote) (= ztag :syntax-quote))\n      (zconstant? (zfirst zloc))\n      (and (not (z-coll? zloc))\n           (or (zkeyword? zloc)\n               #_(println \"zconstant? - not keyword:\" (z/string zloc))\n               (when (zsexpr? zloc)\n                 #_(println \"zconstant?:\" (z/string zloc)\n                            \"\\n z-coll?\" (z-coll? zloc)\n                            \"z/tag:\" (z/tag zloc))\n                 (let [sexpr (sexpr zloc)]\n                   (or (string? sexpr)\n                       (number? sexpr)\n                       (= \"true\" (str sexpr))\n                       (= \"false\" (str sexpr))))))))))\n\n;;\n;; # Integrate specs with doc-string\n;;\n;; Find find-docstring could be a lot smarter, and perhaps\n;; find the docstring in the meta data (so that, defn might\n;; work, for instance).\n\n(defn find-doc-in-map\n  \"Given a zloc zipper of a map, find the :doc element.\"\n  [zloc]\n  (loop [nloc (z/down zloc)]\n    (when nloc\n      (if (and (zkeyword? nloc) (= (z/string nloc) \":doc\"))\n        (when (string? (sexpr (z/right nloc))) (z/right nloc))\n        (recur (z/right (z/right nloc)))))))\n\n(defn find-docstring\n  \"Find a docstring in a zipper of a function.\"\n  [zloc]\n  (let [fn-name (z/string (z/down zloc))]\n    (cond (or (= fn-name \"defn\") (= fn-name \"defmacro\"))\n            (let [docloc (z/right (z/right (z/down zloc)))]\n              (when (string? (sexpr docloc)) docloc))\n          (= fn-name \"def\") (let [maploc (z/down (z/right (z/down zloc)))]\n                              (when (z/map? maploc) (find-doc-in-map maploc)))\n          :else nil)))\n\n(defn add-spec-to-docstring\n  \"Given a zipper of a function definition, add the spec info to\n  the docstring. Works for docstring with (def ...) functions, but\n  the left-indent isn't optimal.  But to fix that, we'd have to do\n  the zprinting here, where we know the indent of the existing\n  docstring.\"\n  [zloc spec-str]\n  #_(println \"spec-str:\" spec-str)\n  (if-let [doc-zloc (find-docstring zloc)]\n    (let [new-doc-zloc (replace* doc-zloc\n                                 (z/node (edn* (p/parse-string\n                                                 (str \"\\\"\"\n                                                      (str (sexpr doc-zloc))\n                                                      spec-str\n                                                      \"\\\"\")))))]\n      (edn* (z/root new-doc-zloc)))\n    zloc))\n\n(defn zlift-ns\n  \"Perform a lift-ns on a pair-seq that is returned from\n  partition-2-all-nc, which is a seq of pairs of zlocs that may or\n  may not have been sorted and which may or may not have had things\n  removed from it and may or may not actually be pairs.  Could be\n  single things, could be multiple things.  If contains multiple\n  things, the first thing is the key, but if it is just a single\n  thing, the first thing is *not* a key. So we only need to work\n  on the first of each seq which has more than one element in it,\n  and possibly replace it. This will only lift out a ns if all keys\n  in seqs with more than one element have the same namespace. Returns\n  the [namespace pair-seq] or nil.\"\n  [{:keys [in-code? lift-ns? lift-ns-in-code? unlift-ns?], :as map-options}\n   pair-seq ns]\n  #_(println \"zlift-ns: lift-ns?\" lift-ns?)\n  (cond\n    (and lift-ns? (if in-code? lift-ns-in-code? true))\n      (if ns\n        ; Already lifted, leave it alone\n        ;\n        ; One option might be to only lift it if there is more than one\n        ; key-value pair, since a lifted namespace with a single key-value\n        ; pair is kind of odd.  That would solve the deps.edn problem.\n        ; Note that it is not trivial to figure out how many key-value pairs\n        ; there are here, since pair-seq isn't really all key-value pairs.\n        [ns pair-seq]\n        ; Needs a lift, if possible\n        (let [strip-ns (fn [named]\n                         (if (symbol? named)\n                           (symbol nil (name named))\n                           (keyword nil (name named))))]\n          (loop [ns nil\n                 pair-seq pair-seq\n                 out []]\n            (let [[k & rest-of-pair :as pair] (first pair-seq)\n                  #_(println \"k:\" k \"rest-of-x-pair:\" rest-of-pair)\n                  current-ns\n                    (when (and ; This is at least a pair\n                            rest-of-pair\n                            ; It does not include an implicit ns\n                            (not (clojure.string/starts-with? (z/string k)\n                                                              \"::\"))\n                            (or (zkeyword? k) (zsymbol? k)))\n                      (namespace (z/sexpr k)))]\n              (if-not k\n                (when ns [(str \":\" ns) out])\n                (if current-ns\n                  (if ns\n                    (when (= ns current-ns)\n                      (recur ns\n                             (next pair-seq)\n                             (conj out\n                                   (cons (edn* (n/token-node (strip-ns (z/sexpr\n                                                                         k))))\n                                         rest-of-pair))))\n                    (recur current-ns\n                           (next pair-seq)\n                           (conj out\n                                 (cons (edn* (n/token-node (strip-ns (z/sexpr\n                                                                       k))))\n                                       rest-of-pair))))\n                  (when (= (count pair) 1)\n                    (recur ns (next pair-seq) (conj out pair)))))))))\n    (and ns unlift-ns? (not lift-ns?))\n      ; We have a namespace that was already lifted, and we want to unlift\n      ; it, and we didn't ask to have things lifted.  That last is so that\n      ; lift-ns? has to be false for unlift-ns? to work.\n      (loop [pair-seq pair-seq\n             out []]\n        (let [[k & rest-of-pair :as pair] (first pair-seq)\n              #_(println \"k:\" k \"rest-of-y-pair:\" rest-of-pair)\n              current-ns\n                (when (and ; This is at least a pair\n                        rest-of-pair\n                        ; It does not include an implicit ns\n                        (not (clojure.string/starts-with? (z/string k) \"::\"))\n                        (or (zkeyword? k) (zsymbol? k)))\n                  (namespace (z/sexpr k)))]\n          (if-not k\n            [nil out]\n            (cond current-ns [ns pair-seq]\n                  (= (count pair) 1) (recur (next pair-seq) (conj out pair))\n                  :else\n                    (recur\n                      (next pair-seq)\n                      (conj out\n                            ; put ns with k\n                            (cons (edn* (n/token-node\n                                          (symbol\n                                            (str ns \"/\" (name (z/sexpr k))))))\n                                  rest-of-pair)))))))\n    :else [ns pair-seq]))\n\n;!zprint {:vector {:respect-nl? true}}\n(defn zredef-call\n  \"Redefine all of the traversal functions for zippers, then\n  call the function of no arguments passed in.\"\n  [body-fn]\n  (#?@(:clj [do-redef-vars :zipper]\n       :cljs [with-redefs])\n   [zprint.zfns/zstring z/string\n    zprint.zfns/znumstr znumstr\n    zprint.zfns/zbyte-array? (constantly false)\n    zprint.zfns/zcomment? zcomment?\n    zprint.zfns/zsexpr sexpr\n    zprint.zfns/zseqnws zseqnws\n    zprint.zfns/zseqnws-w-nl zseqnws-w-nl\n    zprint.zfns/zseqnws-w-bl zseqnws-w-bl\n    zprint.zfns/zfocus-style zfocus-style\n    zprint.zfns/zstart zstart\n    zprint.zfns/zfirst zfirst\n    zprint.zfns/zfirst-no-comment zfirst-no-comment\n    zprint.zfns/zsecond zsecond\n    zprint.zfns/zsecond-no-comment zsecond-no-comment\n    zprint.zfns/zthird zthird\n    zprint.zfns/zthird-no-comment zthird-no-comment\n    zprint.zfns/zfourth zfourth\n    zprint.zfns/znextnws zrightnws\n    zprint.zfns/znextnws-w-nl znextnws-w-nl\n    zprint.zfns/znthnext znthnext\n    zprint.zfns/zcount zcount\n    zprint.zfns/zcount-zloc-seq-nc-nws zcount-zloc-seq-nc-nws\n    zprint.zfns/zmap zmap\n    zprint.zfns/zmap-w-nl zmap-w-nl\n    zprint.zfns/zmap-w-bl zmap-w-bl\n    zprint.zfns/zmap-w-nl-comma zmap-w-nl-comma\n    zprint.zfns/zanonfn? zanonfn?\n    zprint.zfns/zfn-obj? (constantly false)\n    zprint.zfns/zfocus zfocus\n    zprint.zfns/zfind-path find-root-and-path-nw\n    zprint.zfns/zwhitespace? whitespace?\n    zprint.zfns/zlist? z/list?\n    zprint.zfns/zvector? z/vector?\n    zprint.zfns/zmap? z/map?\n    zprint.zfns/znamespacedmap? znamespacedmap?\n    zprint.zfns/zset? z/set?\n    zprint.zfns/zcoll? z-coll?\n    zprint.zfns/zuneval? zuneval?\n    zprint.zfns/zmeta? zmeta?\n    zprint.zfns/ztag ztag\n    zprint.zfns/zlast zlast\n    zprint.zfns/zarray? (constantly false)\n    zprint.zfns/zatom? (constantly false)\n    zprint.zfns/zderef (constantly false)\n    zprint.zfns/zrecord? (constantly false)\n    zprint.zfns/zns? (constantly false)\n    zprint.zfns/zobj-to-vec (constantly nil)\n    zprint.zfns/zexpandarray (constantly nil)\n    zprint.zfns/znewline? znewline?\n    zprint.zfns/zwhitespaceorcomment? whitespace-or-comment?\n    zprint.zfns/zmap-all zmap-all\n    zprint.zfns/zpromise? (constantly false)\n    zprint.zfns/zfuture? (constantly false)\n    zprint.zfns/zdelay? (constantly false)\n    zprint.zfns/zkeyword? zkeyword?\n    zprint.zfns/zconstant? zconstant?\n    zprint.zfns/zagent? (constantly false)\n    zprint.zfns/zreader-macro? zreader-macro?\n    zprint.zfns/zarray-to-shift-seq (constantly nil)\n    zprint.zfns/zdotdotdot zdotdotdot\n    zprint.zfns/zsymbol? zsymbol?\n    zprint.zfns/znil? znil?\n    zprint.zfns/zreader-cond-w-symbol? zreader-cond-w-symbol?\n    zprint.zfns/zreader-cond-w-coll? zreader-cond-w-coll?\n    zprint.zfns/zlift-ns zlift-ns\n    zprint.zfns/zfind zfind\n    zprint.zfns/ztake-append ztake-append]\n   (body-fn)))"]}