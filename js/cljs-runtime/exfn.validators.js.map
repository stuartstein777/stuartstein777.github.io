{"version":3,"sources":["exfn/validators.cljs"],"mappings":"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","names":["exfn.validators/has-two-arguments?","line","cljs.core._EQ_","cljs.core/count","cljs.core/first","exfn.validators/has-one-argument?","exfn.validators/has-no-arguments?","exfn.validators/first-argument-is-a-register?","clojure.string/starts-with?","cljs.core/second","exfn.validators/rules","exfn.validators/get-section","code","pred__34449","expr__34450","js/Error","cljs.core/=","exfn.validators/join","suggestions","pred__34452","expr__34453","clojure.string.join","cljs.core/butlast","cljs.core/last","exfn.validators/build-error","invalid-instruction","line-no","replacements","is-macro?","exfn.helpers/get-suggestions-for-invalid-instruction","exfn.validators/validate-macro-call","acc","macro-names","macro-call","macro-name","cljs.core.apply","cljs.core/str","p1__34455#","cljs.core.take_while","cljs.core.not_EQ_","cljs.core.update","cljs.core/conj","p__34456","map__34457","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get","exfn.validators/validate-line","in-macro?","vec__34459","seq__34460","cljs.core/seq","first__34461","cljs.core/next","instruction","args","clojure.string.split","cljs.core/re-find","cljs.core/not","exfn.helpers/valid-instructions","p__34462","p__34463","map__34464","vec__34465","cljs.core.nth","exfn.validators/verify","current-section","open-macro","cljs.core.assoc","exfn.errors/invalid-macro-end","cljs.core.subs","exfn.errors/invalid-macro-definition","exfn.validators/sample-code","exfn.validators/validate","cljs.core.map","cljs.core/vector","cljs.core.range","cljs.core.reduce"],"sourcesContent":["(ns exfn.validators\n  (:require [clojure.string :as str]\n            [exfn.helpers :as h]\n            [exfn.errors :as err]))\n\n;; this is the result of calling prepare-source\n;; code is broken into lines.\n\n(defn has-two-arguments? [line]\n  (if (= (count line) 3)\n    \"\"\n    (str (first line) \" requires 2 arguments.\")))\n\n(defn has-one-argument? [line]\n  (= (count line) 2))\n\n(defn has-no-arguments? [line]\n  (= (count line) 1))\n\n(defn first-argument-is-a-register? [line]\n  (str/starts-with? (second line) \":\"))\n\n(def rules {:mov [has-two-arguments? first-argument-is-a-register?]})\n\n(defn get-section [code]\n  (condp = code\n    \".data\" :data\n    \".code\" :code\n    \".macros\" :macro))\n\n(defn join [suggestions]\n  (condp = (count suggestions)\n    1 (first suggestions)\n    2 (str (first suggestions) \" or \" (second suggestions))\n    (str (str/join \", \" (butlast suggestions)) \" or \" (last suggestions))))\n\n(defn build-error [invalid-instruction line-no replacements is-macro?]\n  (let [suggestions (h/get-suggestions-for-invalid-instruction invalid-instruction replacements)]\n    (if (> (count suggestions) 4)\n      (str line-no \": Invalid \" (if is-macro? \"macro call `\" \"instruction `\") invalid-instruction)\n      (str line-no \": Invalid \" (if is-macro? \"macro call `\" \"instruction `\") invalid-instruction \"`. Did you mean \" (join suggestions) \"?\"))))\n\n;;=================================================================================================================\n;; Want to check the macro call is a valid macro-call. That is, it is in the list of macro-names.\n;; If it isn't then we need to get suggestions for possible macro-names (if possible).\n;; If errors, return new acc with conj'd error.\n;;\n;; macro call with be off the form\n;;    sum-and-square(:a, :b)\n;;    add-ten(:a)\n;;    foobar()\n;;\n;; Need to strip out everything before bracket to just sum-and-square\n;; \n;; Otherwise return acc.\n;;=================================================================================================================\n(defn validate-macro-call [acc macro-names macro-call line-no]\n  (let [macro-name (apply str (take-while #(not= \\( %) macro-call))]\n    (if (macro-names macro-name)\n      acc\n      (update acc :errors conj (build-error macro-call line-no macro-names true)))))\n\n;;=================================================================================================================\n;; validate-line\n;;\n;; Return new accumulator for the reduce. Want to set errors if line doesnt' validate.\n;;=================================================================================================================\n(defn validate-line [{:keys [in-macro?] :as acc} line-no code in-macro? macro-names]\n  (let [[instruction & args] (str/split code #\" \")]\n\n    (cond\n      ;; it looks like a macro call:\n      (re-find #\"(\\(\\)|(\\(.+?\\)))\" code)\n      (validate-macro-call acc macro-names code line-no)\n\n      ;; handle if it looks like a label:\n      (re-find #\"\\w+:\" code)\n      acc\n\n      :else\n      (if (not (h/valid-instructions instruction))\n        (update acc :errors conj (build-error instruction line-no h/valid-instructions false))\n        acc))))\n\n(defn verify [{:keys [current-section open-macro macro-names] :as acc} [line-no code]]\n  #_(prn \"current-section: \" current-section \", open-macro: \" open-macro \", line \" line-no \": \" code)\n  (cond\n    ; current line is the start of the macro definitions section. So mark us as in macro section.\n    (or (= code \".macros\") (= code \".code\") (= code \".data\"))\n    (assoc acc :current-section (get-section code))\n\n    ;; macro parsing --------------------------------------------------------------------------------------\n    ;; TODO: Can move all this out to a macro parse function.\n    ; if we are in a macro, and we hit a %end line, then close the current macro.\n    (and (= :macro current-section) (= code \"%end\") open-macro)\n    (assoc acc :open-macro false)\n\n    ; if we are not in a macro, and we hit a %end line, then this is a syntax error, show error about how to start a macro definition..\n    (and (= :macro current-section) (= code \"%end\") (not open-macro))\n    (update acc :errors conj (str line-no err/invalid-macro-end))\n\n    ; we are not in a macro definition and we hit a line that starts with %, so open a macro.\n    (and (= :macro current-section) (str/starts-with? code \"%\") (not open-macro))\n    (-> acc\n        (assoc :open-macro true)\n        (update :macro-names conj (subs code 1)))\n\n    ; we are in a macro definition and hit a line that starts with %, assume its a new macro definition and show error about missing end.\n    ; wont be an end, the earlier case would case catch that.\n    (and (= :macro current-section) (str/starts-with? code \"%\") open-macro)\n    (update acc :errors conj (str line-no err/invalid-macro-definition))\n\n    ; we are in a macro section, but not an open macro and we hit a line that doesnt start with %, assume its an instruction and show\n    ; error about adding a macro start definition.\n    (and (= :macro current-section) (not (str/starts-with? code \"%\")) (not open-macro))\n    (update acc :errors conj (str line-no \": Any instructions in a macro section should be between a macro definition. Macro definitions start with %macro-name and end with %end\\n\"\n                                  \"e.g.\\n\"\n                                  \"%square-and-sum\\n\"\n                                  \"   mul %1 %1\\n\"\n                                  \"   mul %2 %2\\n\"\n                                  \"   add %1 %2\\n\"\n                                  \"%end\"))\n\n    ;; in a macro, line doesnt start with % so its an instruction. Parse the instruction.\n    (and (= :macro current-section) (not (str/starts-with? code \"%\")) open-macro)\n    (validate-line acc line-no code true macro-names)\n\n    (= :code current-section)\n    (validate-line acc line-no code false macro-names)\n\n    ;; code parsing ---------------------------------------------------------------------------------------\n\n    :else\n    acc))\n\n(def sample-code '(\".macros\"\n                   \"%square-and-sum\"\n                   \"mul %1 %1\"\n                   \"muk %2 %2\"\n                   \"add %1 %2\"\n                   \"%end\"\n                   \"%add-ten\"\n                   \"add %1 10\"\n                   \"%end\"\n                   \".code\"\n                   \"mov :a 0\"\n                   \"mov :b 1\"\n                   \"squareandsub(:a, :b)\"\n                   \"mov :c 2\"\n                   \"prn :b\"\n                   \"call foo\"\n                   \"mul :c :b\"\n                   \"cmp :a :b\"\n                   \"ffne quax\"\n                   \"mul :c 10\"\n                   \"quax:\"\n                   \"nop\"\n                   \"cdlk bar\"\n                   \"pop :d\"\n                   \"pop :e\"\n                   \"prn :d\"\n                   \"prn :e\"\n                   \"xor :b :b\"\n                   \"end\" \"foo:\"\n                   \"inc :b\"\n                   \"xxx\"\n                   \"ret\"\n                   \"bar:\"\n                   \"add :a 7\"\n                   \"sub :c 1\"\n                   \"push 3\"\n                   \"push 4\"\n                   \"wet\"\n                   \".data\"\n                   \"xyz 123\"))\n\n(defn validate [code]\n  ;; want line numbers with each line.\n  (->> (map vector (range (count sample-code)) sample-code)\n       (reduce verify {:current-section nil\n                       :errors          []\n                       :macro-names     #{}\n                       :open-macro      false})\n       :errors))\n\n"]}