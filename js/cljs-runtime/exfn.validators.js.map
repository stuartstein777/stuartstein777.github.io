{"version":3,"sources":["exfn/validators.cljs"],"mappings":"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","names":["exfn.validators/valid-instructions","exfn.validators/sample-code","exfn.validators/has-two-arguments?","line","cljs.core._EQ_","cljs.core/count","cljs.core/first","exfn.validators/has-one-argument?","exfn.validators/has-no-arguments?","exfn.validators/first-argument-is-a-register?","clojure.string/starts-with?","cljs.core/second","exfn.validators/rules","exfn.validators/get-section","code","pred__34298","expr__34299","js/Error","cljs.core/=","exfn.validators/parse-instruction","acc","line-no","in-macro?","vec__34301","seq__34302","cljs.core/seq","first__34303","cljs.core/next","instruction","args","clojure.string.split","p__34304","p__34305","map__34306","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","vec__34307","cljs.core.nth","exfn.validators/verify","current-section","open-macro","cljs.core.assoc","cljs.core/not","cljs.core.update","cljs.core/conj","exfn.validators/validate","lines","cljs.core.map","cljs.core/vector","cljs.core.range","cljs.core.reduce","exfn.validators/get-all-prefixes","s","p1__34311#","cljs.core.subs","cljs.core.drop"],"sourcesContent":["(ns exfn.validators\n  (:require [clojure.string :as str]))\n\n(def valid-instructions #{\"mov\" \"add\" \"sub\" \"div\" \"mul\" \"call\" \"ret\" \"rep\" \"rza\"\n                          \"prn\" \"end\" \"and\" \"or\" \"xor\" \"jmp\" \"jgz\" \"push\" \"pop\" \"nop\"\n                          \"inc\" \"dec\" \"jne\" \"jge\" \"jg\" \"je\" \"jle\" \"jl\" \"rnz\" \"cer\"\n                          \"rz\" \"rlez\" \"rgz\" \"rgez\" \"rlz\"})\n\n;; this is the result of calling prepare-source\n;; code is broken into lines.\n(def sample-code '(\".macros\"\n                   ;\"mul %1 %1\"\n                   \"%square-and-sum\"\n                   \"mul %1 %1\"\n                   \"mul %2 %2\"\n                   \"add %1 %2\"\n                   \"%end\"\n                   \"%add-ten\"\n                   \"add %1 10\"\n                   \"%end\"\n                   \".code\"\n                   \"mov :a 0\"\n                   \"mov :b 1\"\n                   \"square-and-sum(:a, :b)\"\n                   \"mov :c 2\"\n                   \"prn :b\"\n                   \"call foo\"\n                   \"mul :c :b\"\n                   \"cmp :a :b\"\n                   \"jne quax\"\n                   \"mul :c 10\"\n                   \"quax:\"\n                   \"nop\"\n                   \"call bar\"\n                   \"pop :d\"\n                   \"pop :e\"\n                   \"prn :d\"\n                   \"prn :e\"\n                   \"xor :b :b\"\n                   \"end\" \"foo:\"\n                   \"inc :b\"\n                   \"ret\"\n                   \"bar:\"\n                   \"add :a 7\"\n                   \"sub :c 1\"\n                   \"push 3\"\n                   \"push 4\"\n                   \"ret\"\n                   \".data\"\n                   \"xyz 123\"))\n\n(defn has-two-arguments? [line]\n  (if (= (count line) 3)\n    \"\"\n    (str (first line) \" requires 2 arguments.\")))\n\n(defn has-one-argument? [line]\n  (= (count line) 2))\n\n(defn has-no-arguments? [line]\n  (= (count line) 1))\n\n(defn first-argument-is-a-register? [line]\n  (str/starts-with? (second line) \":\"))\n\n(def rules {:mov [has-two-arguments? first-argument-is-a-register?]})\n\n(defn get-section [code]\n  (condp = code\n    \".data\" :data\n    \".code\" :code\n    \".macros\" :macro))\n\n(defn parse-instruction [acc line-no code in-macro?]\n  (let [[instruction & args] (str/split \"mul %1 %1\" #\" \")]\n    (if (valid-instructions instruction)\n\n      (str line-no \": Invalid instruction.\"))))\n\n(defn verify [{:keys [current-section open-macro] :as acc} [line-no code]]\n  #_(prn \"current-section: \" current-section \", open-macro: \" open-macro \", line \" line-no \": \" code)\n  (cond\n    ; current line is the start of the macro definitions section. So mark us as in macro section.\n    (or (= code \".macros\") (= code \".code\") (= code \".data\"))\n    (assoc acc :current-section (get-section code))\n\n    ;; macro parsing --------------------------------------------------------------------------------------\n    ;; TODO: Can move all this out to a macro parse function.\n    ; if we are in a macro, and we hit a %end line, then close the current macro.\n    (and (= :macro current-section) (= code \"%end\") open-macro)\n    (assoc acc :open-macro false)\n\n    ; if we are not in a macro, and we hit a %end line, then this is a syntax error, show error about how to start a macro definition..\n    (and (= :macro current-section) (= code \"%end\") (not open-macro))\n    (update acc :errors conj (str line-no \": Invalid macro end definition. Macros start definitions should be of the form %macro-name\"))\n\n    ; we are not in a macro definition and we hit a line that starts with %, so open a macro.\n    (and (= :macro current-section) (str/starts-with? code \"%\") (not open-macro))\n    (assoc acc :open-macro true)\n\n    ; we are in a macro definition and hit a line that starts with %, assume its a new macro definition and show error about missing end.\n    (and (= :macro current-section) (str/starts-with? code \"%\") (not open-macro))\n    (update acc :errors conj (str line-no \": Invalid macro start definition. Previous macro was not closed. Are you missing %end ?\"))\n\n    ; we are in a macro section, but not an open macro and we hit a line that doesnt start with %, assume its an instruction and show\n    ; error about adding a macro start definition.\n    (and (= :macro current-section) (not (str/starts-with? code \"%\")) (not open-macro))\n    (update acc :errors conj (str line-no \": Any instructions in a macro section should be between a macro definition. Macro definitions start with %macro-name and end with %end\\n\"\n                                  \"e.g.\\n\"\n                                  \"%square-and-sum\\n\"\n                                  \"   mul %1 %1\\n\"\n                                  \"   mul %2 %2\\n\"\n                                  \"   add %1 %2\\n\"\n                                  \"%end\"))\n\n    ;; in a macro, line doesnt start with % so its an instruction. Parse the instruction.\n    (and (= :macro current-section) (not (str/starts-with? code \"%\")) open-macro)\n    #_(parse-instruction line-no code open-macro)\n    acc\n\n    ;; code parsing ---------------------------------------------------------------------------------------\n\n    :else\n    acc))\n\n(defn validate [lines]\n  ;; want line numbers with each line.\n  (->> (map vector (range (count sample-code)) sample-code)\n       (reduce verify {:current-section  nil\n                       :open-macro  false\n                       :errors           []})\n       :errors))\n\n(defn get-all-prefixes [s]\n  (->> (range (inc (count s)))\n       (map #(subs s 0 %))\n       (drop 1)))\n\n\n"]}