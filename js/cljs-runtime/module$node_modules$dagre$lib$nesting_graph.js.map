{
"version":3,
"file":"module$node_modules$dagre$lib$nesting_graph.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/dagre/lib/nesting-graph.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$dagre$lib$nesting_graph\"] = function(global,require,module,exports) {\nvar _ = require(\"./lodash\");\nvar util = require(\"./util\");\n\nmodule.exports = {\n  run: run,\n  cleanup: cleanup\n};\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run(g) {\n  var root = util.addDummyNode(g, \"root\", {}, \"_root\");\n  var depths = treeDepths(g);\n  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array\n  var nodeSep = 2 * height + 1;\n\n  g.graph().nestingRoot = root;\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  var weight = sumWeights(g) + 1;\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function(child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n  });\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep;\n}\n\nfunction dfs(g, root, nodeSep, weight, height, depths, v) {\n  var children = g.children(v);\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep });\n    }\n    return;\n  }\n\n  var top = util.addBorderNode(g, \"_bt\");\n  var bottom = util.addBorderNode(g, \"_bb\");\n  var label = g.node(v);\n\n  g.setParent(top, v);\n  label.borderTop = top;\n  g.setParent(bottom, v);\n  label.borderBottom = bottom;\n\n  _.forEach(children, function(child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n\n    var childNode = g.node(child);\n    var childTop = childNode.borderTop ? childNode.borderTop : child;\n    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;\n    var thisWeight = childNode.borderTop ? weight : 2 * weight;\n    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n  });\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });\n  }\n}\n\nfunction treeDepths(g) {\n  var depths = {};\n  function dfs(v, depth) {\n    var children = g.children(v);\n    if (children && children.length) {\n      _.forEach(children, function(child) {\n        dfs(child, depth + 1);\n      });\n    }\n    depths[v] = depth;\n  }\n  _.forEach(g.children(), function(v) { dfs(v, 1); });\n  return depths;\n}\n\nfunction sumWeights(g) {\n  return _.reduce(g.edges(), function(acc, e) {\n    return acc + g.edge(e).weight;\n  }, 0);\n}\n\nfunction cleanup(g) {\n  var graphLabel = g.graph();\n  g.removeNode(graphLabel.nestingRoot);\n  delete graphLabel.nestingRoot;\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.nestingEdge) {\n      g.removeEdge(e);\n    }\n  });\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","dfs","g","root","nodeSep","weight","height","depths","v","children","length","top","util","addBorderNode","bottom","label","node","setParent","borderTop","borderBottom","_","forEach","child","childNode","childTop","childBottom","thisWeight","minlen","setEdge","nestingEdge","parent","treeDepths","depth","sumWeights","reduce","edges","acc","e","edge","run","addDummyNode","max","values","graph","nestingRoot","nodeRankFactor","cleanup","graphLabel","removeNode","removeEdge"]
}
