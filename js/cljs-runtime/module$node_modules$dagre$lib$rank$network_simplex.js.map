{
"version":3,
"file":"module$node_modules$dagre$lib$rank$network_simplex.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/dagre/lib/rank/network-simplex.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$dagre$lib$rank$network_simplex\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _ = require(\"../lodash\");\nvar feasibleTree = require(\"./feasible-tree\");\nvar slack = require(\"./util\").slack;\nvar initRank = require(\"./util\").longestPath;\nvar preorder = require(\"../graphlib\").alg.preorder;\nvar postorder = require(\"../graphlib\").alg.postorder;\nvar simplify = require(\"../util\").simplify;\n\nmodule.exports = networkSimplex;\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function(v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function(e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function(w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function(e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function(edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _.minBy(candidates, function(edge) { return slack(g, edge); });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function(v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","networkSimplex","g","simplify","initRank","t","feasibleTree","initLowLimValues","initCutValues","e","f","leaveEdge","enterEdge","exchangeEdges","vs","postorder","nodes","slice","length","_","forEach","v","parent","childLab","node","edge","cutvalue","calcCutValue","child","childIsTail","graphEdge","cutValue","weight","nodeEdges","isOutEdge","other","w","pointsToHead","otherWeight","hasEdge","otherCutValue","tree","root","arguments","dfsAssignLowLim","visited","nextLim","low","label","neighbors","has","lim","find","edges","vLabel","wLabel","tailLabel","flip","candidates","filter","rootLabel","minBy","slack","removeEdge","setEdge","updateRanks","preorder","flipped","rank","minlen","longestPath","alg"]
}
