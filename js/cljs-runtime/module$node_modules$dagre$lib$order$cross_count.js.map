{
"version":3,
"file":"module$node_modules$dagre$lib$order$cross_count.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAe,+CAAf,CAAoE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA+B5GC,QAASA,mBAAkB,CAACC,CAAD,CAAIC,UAAJ,CAAgBC,UAAhB,CAA4B,CAIrD,IAAIC,SAAWC,CAAA,CAAEC,SAAF,CAAYH,UAAZ,CACbE,CAAA,CAAEE,GAAF,CAAMJ,UAAN,CAAkB,QAAS,CAACK,CAAD,CAAIC,CAAJ,CAAO,CAAE,MAAOA,EAAT,CAAlC,CADa,CAEXC,WAAAA,CAAeL,CAAA,CAAEM,OAAF,CAAUN,CAAA,CAAEE,GAAF,CAAML,UAAN,CAAkB,QAAQ,CAACM,CAAD,CAAI,CACzD,MAAOH,EAAA,CAAEO,MAAF,CAASP,CAAA,CAAEE,GAAF,CAAMN,CAAA,CAAEY,QAAF,CAAWL,CAAX,CAAN,CAAqB,QAAQ,CAACM,CAAD,CAAI,CAC/C,MAAO,CAAEC,IAAKX,QAAA,CAASU,CAAT,CAAWE,CAAX,CAAP,CAAsBC,OAAQhB,CAAA,CAAEiB,IAAF,CAAOJ,CAAP,CAARG,CAAkBA,MAAxC,CADwC,CAAjC,CAAT,CAEH,KAFG,CADkD,CAA9B,CAAV,CAIf,CAAA,CAJe,CAQnB,KADA,IAAIE,WAAa,CACjB,CAAOA,UAAP,CAAoBhB,UAApB,CAA+BiB,MAA/B,CAAA,CAAuCD,UAAA,GAAe,CAClDE,WAAAA,CAAW,CAAXA,CAAeF,UAAfE,CAA4B,CAChC,GAAAF,UACA;IAAIG,KAAOjB,CAAA,CAAEE,GAAF,CAAUgB,KAAJ,CAAUF,UAAV,CAAN,CAA2B,QAAQ,EAAG,CAAE,MAAO,EAAT,CAAtC,CAAX,CAGIG,GAAK,CACTnB,EAAA,CAAEoB,OAAF,CAAUf,UAAA,CAAae,OAAb,CAAqB,QAAQ,CAACC,KAAD,CAAQ,CAC7C,IAAIC,MAAQD,KAARC,CAAcZ,GAAdY,CAAoBR,UACxBG,KAAA,CAAKK,KAAL,CAAA,EAAeD,KAAf,CAAqBT,MAErB,KADA,IAAIW,UAAY,CAChB,CAAe,CAAf,CAAOD,KAAP,CAAA,CACMA,KAIJ,CAJY,CAIZ,GAHEC,SAGF,EAHeN,IAAA,CAAKK,KAAL,CAAa,CAAb,CAGf,EADAA,KACA,CADSA,KACT,CADiB,CACjB,EADuB,CACvB,CAAAL,IAAA,CAAKK,KAAL,CAAA,EAAeD,KAAf,CAAqBT,MAEvBO,GAAA,EAAME,KAAN,CAAYT,MAAZ,CAAqBW,SAXwB,CAArC,CAAV,CAcA,OAAOJ,GAnC8C,CA5BvD,IAAInB,EAAIR,OAAA,CAAQ,sCAAR,CAERC,OAAA,CAAOC,OAAP,CAkBA8B,QAAmB,CAAC5B,CAAD,CAAI6B,QAAJ,CAAc,CAE/B,IADA,IAAIN,GAAK,CAAT,CACSf,EAAI,CAAb,CAAgBA,CAAhB,CAAoBqB,QAApB,CAA6BV,MAA7B,CAAqC,EAAEX,CAAvC,CACEe,EAAA,EAAMxB,kBAAA,CAAmBC,CAAnB,CAAsB6B,QAAA,CAASrB,CAAT,CAAW,CAAX,CAAtB,CAAqCqB,QAAA,CAASrB,CAAT,CAArC,CAER,OAAOe,GALwB,CAvB2E;",
"sources":["node_modules/dagre/lib/order/cross-count.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$dagre$lib$order$cross_count\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _ = require(\"../lodash\");\n\nmodule.exports = crossCount;\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(southLayer,\n    _.map(southLayer, function (v, i) { return i; }));\n  var southEntries = _.flatten(_.map(northLayer, function(v) {\n    return _.sortBy(_.map(g.outEdges(v), function(e) {\n      return { pos: southPos[e.w], weight: g.edge(e).weight };\n    }), \"pos\");\n  }), true);\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function() { return 0; });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(southEntries.forEach(function(entry) {\n    var index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    var weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = (index - 1) >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  }));\n\n  return cc;\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","twoLayerCrossCount","g","northLayer","southLayer","southPos","_","zipObject","map","v","i","southEntries","flatten","sortBy","outEdges","e","pos","w","weight","edge","firstIndex","length","treeSize","tree","Array","cc","forEach","entry","index","weightSum","crossCount","layering"]
}
