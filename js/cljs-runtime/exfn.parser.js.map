{"version":3,"sources":["exfn/parser.cljs"],"mappings":"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","names":["exfn.parser/is-register?","x","cljs.core/boolean","clojure.string/starts-with?","exfn.parser/get-value","cljs.core.keyword","cljs.core.subs","exfn.parser/parse-msg","instruction","cljs.core.into","input","cljs.core.map","cljs.core/identity","to-parse","res","in-quote?","current-string","i","cljs.core/first","cljs.core/empty?","cljs.core.conj","and__4115__auto__","cljs.core._EQ_","cljs.core/rest","cljs.core.not_EQ_","cljs.core/not","exfn.parser/format-arg","arg","cljs.core/re-find","js/Number","cljs.core/count","p__83007","vec__83008","cljs.core.nth","exfn.parser/format-arguments","arg1","arg2","G__83011","exfn.parser/get-first-arg","args","exfn.parser/parse-line-of-code","line","first-arg","second-arg","clojure.string/trim","exfn.parser/scrub-comments","s","clojure.string/includes?","clojure.string/trimr","clojure.string.index_of","exfn.parser/get-macros","source","macro-start","macro-end","macros","cljs.core.drop","cljs.core.take","cljs.core.partition_by","n","p1__83012#","cljs.core.remove","cljs.core/zipmap","p1__83013#","exfn.parser/get-code","code-start","data-start","code-end","exfn.parser/get-macro-call","macro-names","p1__83014#","cljs.core.filter","exfn.parser/get-args","clojure.string.split","cljs.core/re-seq","p1__83015#","cljs.core/seq","cljs.core.range","exfn.parser/replace-macro-args","macro-line","regex","cljs.core/re-pattern","clojure.string.join","cljs.core/keys","clojure.string/replace","exfn.parser/expand","macro","cljs.core.partial","exfn.parser/macro-expand-line","macro-call","cljs.core/List","exfn.parser/macro-expand-code","code","cljs.core.mapcat","exfn.parser/get-data","data-end","exfn.parser/parse-data-entry","data","vec__83016","_","reg","value","exfn.parser/prepare-source","asm","clojure.string/split-lines","p1__83019#","clojure.string/triml","p1__83020#","p1__83021#","exfn.parser/parse","cljs.core.mapv"],"sourcesContent":["(ns exfn.parser\n  (:require [clojure.string :as str]))\n\n(defn is-register? [x]\n  (boolean (str/starts-with? x \":\")))\n\n(defn get-value [x]\n  (if (is-register? x)\n    (keyword (subs x 1))\n    x))\n\n(defn parse-msg [instruction]\n  (into [(keyword (subs instruction 0 3))]\n        (let [input (map identity (subs instruction 4))]\n          (loop [to-parse input\n                 res []\n                 in-quote? false\n                 current-string \"\"]\n            (let [i (first to-parse)]\n              (if (empty? to-parse)\n                (conj res (get-value current-string))\n                (cond\n                  (and in-quote? (= i \\'))\n                  (recur (rest to-parse) (conj res current-string) false \"\")\n\n                  (and in-quote? (not= i \\'))\n                  (recur (rest to-parse) res in-quote? (str current-string (str i)))\n\n                  (and (not in-quote?) (= i \\'))\n                  (recur (rest to-parse) (if (= \"\" current-string)\n                                           res\n                                           (conj res (get-value current-string))) true \"\")\n\n                  (and (not in-quote?) (= i \\space))\n                  (recur (rest to-parse) res in-quote? current-string)\n\n                  (and (not in-quote?) (= i \\;))\n                  (conj res (get-value current-string))\n\n                  :else\n                  (recur (rest to-parse) res in-quote? (str current-string (str i))))))))))\n\n;; ==============================================================================================\n;; Takes the arguments for a line of source code and formats them depending on their\n;; type.\n;;\n;; Valid argument types:\n;;    keyword - meaning its a register.\n;;    number  - meaning its a number.\n;;    string  - starts with ` or '\n;;    else return it as a keyword.\n;; ==============================================================================================\n(defn format-arg [arg]\n  (cond (is-register? arg)\n        (keyword (subs arg 1))\n\n        (re-find #\"(\\d+)\" arg)\n        (js/Number arg)\n\n        (or (str/starts-with? arg \"'\") (str/starts-with? arg \"`\"))\n        (subs arg 1 (dec (count arg)))\n\n        :else\n        (keyword arg)))\n\n;; ==============================================================================================\n;; Formats the arguments, handles if their are 0, 1 or 2 args.\n;; ==============================================================================================\n(defn format-arguments [[instruction arg1 arg2]]\n  (cond-> [(keyword instruction)]\n    arg1 (conj (format-arg arg1))\n    (and (some? arg2) (not= \"\" arg2)) (conj (format-arg arg2))))\n\n(comment \"format-argument takes instruction and its args as a vector. Returns them formatted for\n          interpreter. Handles 0, 1 or 2 args. e.g:\"\n         (format-arguments [\"mov\" \":a\" \"5\"])\n         (format-arguments [\"mov\" \":a\" \":b\"])\n         (format-arguments [\"call\" \"foo\"])\n         (format-arguments [\"ret\"])\n         (format-arguments [\"rep 5\"]))\n\n(defn get-first-arg [args]\n  (cond\n    ; first argument is a register\n    (str/starts-with? args \":\")\n    (->> args\n         (re-find #\"^(\\:\\w+)\")\n         (first))\n\n    ; first argument is a string\n    (str/starts-with? args \"`\")\n    (first (re-find #\"([`])(?:(?=(\\\\?))\\2.)*?\\1\" args))\n\n    ; first argument is a string\n    (str/starts-with? args \"'\")\n    (first (re-find #\"(['])(?:(?=(\\\\?))\\2.)*?\\1\" args))\n\n    ; first argument is a number.\n    (re-find #\"^\\d\" args)\n    (first (re-find #\"(\\d+)\" args))\n\n    ; first argument is a label\n    :else\n    (first (re-find #\"(\\w+)\" args))))\n\n;; ==============================================================================================\n;; A line will look like this:\n;;\n;; instruction arg1 arg2\n;; arg2 is optional.\n;;\n;; e.g.\n;; mov :a :b\n;; mov :a 'hello, world'\n;; mov :a 555\n;; call foo\n;; prn 555\n;; foo:\n;; prn 'hello, world'\n;; cat 'hello ' 'world'\n;; ret\n;; pop :x\n;; push :x\n;; push `hello, world 'bar', quax`\n;; push `hello, world \"bar\", quax`\n;; push 555\n;;\n;; if arg starts with a : it's a register.\n;; if arg starts with a ' it's a string.\n;; else arg is a number.\n;; ==============================================================================================\n(defn parse-line-of-code [line]  \n  (if (re-find #\"\\w+:$\" line) ; if the line is foo: then its a label.\n    [:label (keyword (subs line 0 (dec (count line))))]\n    (let [instruction (first (re-find #\"^(\\w+)\" line))\n          args (subs line (inc (count instruction)))\n          first-arg (get-first-arg args)\n          second-arg (str/trim (subs args (count first-arg)))]\n      (-> (cond (and (nil? first-arg) (= second-arg \"\"))\n                [instruction]\n                (and first-arg (= second-arg \"\"))\n                [instruction first-arg]\n                :else\n                [instruction first-arg second-arg])\n          (format-arguments)))))\n\n(comment (parse-line-of-code \"prn 'hello world'\")\n         (parse-line-of-code \"prn 555\")\n         (parse-line-of-code \"call foo\")\n         (parse-line-of-code \"foo:\")\n         (parse-line-of-code \"mov :a :b\")\n         (parse-line-of-code \"push `abc 'bar' quax`\")\n         (parse-line-of-code \"cat 'hello ' 'world'\")\n         (parse-line-of-code \"cat `foo 'bar' quax` 'world'\")\n         (parse-line-of-code \"mov :a 555\")\n         (parse-line-of-code \"mov :a 'foo, 'bar', quax'\")\n         (parse-line-of-code \"ret\"))\n\n;; ==============================================================================================\n;; Get rid of all comments, this can be either a line that starts with a ; or a line with a\n;; trailing comment, e.g.\n;;\n;; mov :a :b ; this is a comment.\n;; ==============================================================================================\n(defn scrub-comments [s]\n  (if (and (not (str/starts-with? s \"msg\"))\n           (str/includes? s \";\"))\n    (str/trimr (subs s 0 (str/index-of s \";\")))\n    s))\n\n;; ==============================================================================================\n;; Get all the macros from the macro section.\n;; The input is the source code, split by lines.\n;; Return them in a map keyed on the macro name.\n;; Do not include the % on the start of the name or %end\n;; ==============================================================================================\n(defn get-macros [source]\n  (let [macro-start (.indexOf source \".macros\")\n        macro-end (.indexOf source \".code\")\n        macros (->> source\n                    (drop (inc macro-start))\n                    (take (- (dec macro-end) macro-start))\n                    (partition-by (fn [n] (= n \"%end\")))\n                    (remove #(= '(\"%end\") %)))]\n    (zipmap (->> (map first macros)\n                 (map #(subs % 1)))\n            (map rest macros))))\n\n(comment \"get-macros-test\"\n         (let [prepared-source (list \".macros\" \"%square-and-sum\" \"mul %1 %1\" \"mul %2 %2\" \"add %1 %2\" \"%end\" \"%add-ten\" \"add %1 10\" \"%end\" \".code\" \"mov :a 2\" \"mov :b 5\" \"square-and-sum(:a, :b)\" \"add-ten (:a)\")]\n           (get-macros prepared-source)))\n\n;; ==============================================================================================\n;; Get the code from the .code section.\n;; ==============================================================================================\n(defn get-code [source]\n  (let [code-start (.indexOf source \".code\")\n        data-start (.indexOf source \".data\")\n        code-end (if (= -1 data-start) (count source) data-start)]\n    (->> source\n         (drop (inc code-start))\n         (take (- (dec code-end) code-start)))))\n\n;; + macro expansion ============================================================================\n\n;; ==============================================================================================\n;; Gets the macro call (if it is a macro-call) from the collection of macro names for that line of\n;; code. Returns nil if the line of code is not a macro call.\n;; ==============================================================================================\n(defn get-macro-call [macro-names line]\n  (first (filter #(str/starts-with? line %) macro-names)))\n\n(comment \"get-macro-call examples\"\n         \"returns sum-and-square, since the line starts with sum-and-square, which is in our macro list\"\n         (get-macro-call [\"sum-and-square\" \"add-ten\"] \"sum-and-square(:a, :b)\")\n         \"returns nill since mov :a :b is not a macro\"\n         (get-macro-call [\"sum-and-square\" \"add-ten\"] \"mov :a :b\")\n         \"returns nill, looks like macro but it's not in the list.\"\n         (get-macro-call [\"sum-and-square\" \"add-ten\"] \"foo(:a)\")\n         \"returns add-ten\"\n         (get-macro-call [\"sum-and-square\" \"add-ten\"] \"add-ten(:a)\"))\n\n;; ==============================================================================================\n;; Get the arguments for the macro call.\n;; Takes a line of source for a macro call, e.g,\n;;     sum-and-square(:a, :b)\n;; This method needs to extract the args :a and :b.\n;; This then gets put into a sort of positional map, so the first the arg is :a, it will be keyed\n;; on \"%1\", :b is the second arg so it is keyed on \"%2\".\n;; Input: sum-and-square (:a, :b)\n;; Output: {\"%1\" :a, \"%2\" :b}\n;; This is used as the map input to str/replace for the macro expansion.\n;; If no args, return nil.\n;; ==============================================================================================\n(defn get-args [line]\n  (let [args (->> (str/split (->> (re-seq #\"\\((.*?)\\)\" line)\n                                  (first)\n                                  (rest)\n                                  (first)) \",\")\n                  (remove #(= \"\" %))\n                  (map str/trim))]\n    (when (seq args)\n      (zipmap (->> (range 1 (inc (count args)))\n                   (map (fn [n] (str \"%\" n))))\n              args))))\n\n(comment \"get-args examples:\"\n         (get-args \"sum-and-square(:a, :b)\")\n         (get-args \"foo()\"))\n\n;; ==============================================================================================\n;; Replaces the %1, %2 etc arguments in macro code with the actual arguments from the source call.\n;; e.g.\n;; %sum-and-square\n;;    mul %1 %1\n;;    mul %2 %2\n;;    add %1 %2\n;; %end\n;; .code\n;;   sum-and-square(:a, :b)\n;;\n;; The first line will have to macro expand to:\n;;    mul :a :a\n;;\n;; Takes in the args as keys, these are ordered as positional in the source call. e.g.\n;; sum-and-square(:a, :b) args will be {\"%1\" :a, \"%2\" :b}\n;; ==============================================================================================\n(defn replace-macro-args [args macro-line]\n  (let [regex (re-pattern (str/join \"|\" (keys args)))]\n    (str/replace macro-line regex args)))\n\n(comment \"replacing macro argse example\"\n         (replace-macro-args {\"%1\" \":a\", \"%2\", \":b\"} \"mul %1 %1\")\n         (replace-macro-args {\"%1\" \":a\", \"%2\", \":b\"} \"add %1 %2\"))\n\n;; Need to handle nested macro calls. So bind current result.\n;; call expand again and see if its any different, if its not. we are done.\n(defn expand\n  [line macro] ;\n  (let [args (get-args line)]\n    (if args\n      (map (partial replace-macro-args args) macro)\n      macro)))\n\n(comment \"expand example:\"\n         (expand \"sum-and-square(:a, :b)\" [\"mul %1 %1\" \"mul %2 %2\" \"add %1 %2\"])\n         \"if no arguments, just return the macro\"\n         (expand \"foo()\" [\"foo :a 6\" \"foo :b 7\" \"add :a :b\"]))\n\n(defn macro-expand-line [macros line]\n  (let [macro-call (get-macro-call (keys macros) line)]\n    (if macro-call\n      (expand line (macros macro-call))\n      (list line))))\n\n(comment \"If the line is a macro, expand it, otherwise just return the line (as a list) as we\n          use mapcat to concatenat all the results from macro-expand-line\"\n         (macro-expand-line {\"square-and-sum\" [\"mul %1 %1\" \"mul %2 %2\" \"add %1 %2\"], \"add-ten\" [\"add %1 10\"]}\n                            \"square-and-sum(:a, :b)\")\n         (macro-expand-line {\"square-and-sum\" [\"mul %1 %1\" \"mul %2 %2\" \"add %1 %2\"], \"add-ten\" [\"add %1 10\"]}\n                            \"mov :a 5\"))\n\n(defn macro-expand-code [code macros]\n  (->> (mapcat (partial macro-expand-line macros) code)))\n\n;; - macro expansion ====================================================================\n\n(defn get-data [source]\n  (let [data-start (.indexOf source \".data\")\n        data-end (count source)]\n    (when (not= -1 data-start)\n      (->> source\n           (drop (inc data-start))\n           (take (- (dec data-end) data-start))))))\n\n(defn parse-data-entry [data]\n  (let [[_ reg value] (re-find #\"^(\\w+) (.+)\" data)]\n    [(keyword reg) (format-arg value)]))\n\n(comment \"parse-data-entry\"\n     (parse-data-entry \"foo 42\")\n     (parse-data-entry \"bar `this is a string`\")\n     (parse-data-entry \"quax 'another string'\"))\n\n(defn prepare-source [asm]\n  (->> (str/split-lines asm)\n       (map #(str/trimr (str/triml %)))\n       (map scrub-comments)\n       (remove #(= \"\" %))\n       (remove #(str/starts-with? % \";\"))))\n\n(defn parse [asm]\n  (let [source (prepare-source asm)\n        macros (get-macros source)\n        code (get-code source)\n        data (get-data source)]\n    {:code (->> (macro-expand-code code macros)\n                (map parse-line-of-code))\n     :data (mapv parse-data-entry data)}))\n\n(comment\n  {:code ([:mov :a 2] [:mov :b 5] [:mul :a :a] [:mul :b :b] [:add :a :b] [:add :a 10])\n   :data [\"foo 42\" \"quax `this is a string`\" \"bar 'abc `def` ghi'\"]}\n\n  (parse \";; macros\n          .macros\n          %square-and-sum\n            mul %1 %1\n            mul %2 %2\n            add %1 %2\n          %end\n          %add-ten\n            add %1 10\n          %end\n          .code\n              mov :a 2\n              mov :b 5\n              square-and-sum(:a, :b)\n              add-ten (:a)\n          .data\n              foo 42\n              quax `this is a string`\n              bar 'abc `def` ghi'\"))"]}