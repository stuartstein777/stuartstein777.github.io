{"version":3,"sources":["exfn/parser.cljs"],"mappings":"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","names":["exfn.parser/is-register?","x","cljs.core/boolean","clojure.string/starts-with?","exfn.parser/get-value","cljs.core.keyword","cljs.core.subs","exfn.parser/parse-msg","instruction","cljs.core.into","input","cljs.core.map","cljs.core/identity","to-parse","res","in-quote?","current-string","i","cljs.core/first","cljs.core/empty?","cljs.core.conj","and__4115__auto__","cljs.core._EQ_","cljs.core/rest","cljs.core.not_EQ_","cljs.core/not","exfn.parser/format-arg","arg","cljs.core/re-find","js/Number","cljs.core/count","p__34172","vec__34173","cljs.core.nth","exfn.parser/format-arguments","arg1","arg2","G__34176","exfn.parser/parse-line-of-code","line","args","first-arg","second-arg","clojure.string/trim","exfn.parser/scrub-comments","s","clojure.string/includes?","clojure.string/trimr","clojure.string.index_of","exfn.parser/get-macros","source","macro-start","macro-end","macros","cljs.core.drop","cljs.core.take","cljs.core.partition_by","n","p1__34177#","cljs.core.remove","cljs.core/zipmap","p1__34178#","exfn.parser/get-code","code-start","data-start","code-end","exfn.parser/is-macro-call?","macro-names","p1__34179#","cljs.core.filter","exfn.parser/get-args","clojure.string.split","cljs.core/re-seq","p1__34180#","cljs.core/seq","cljs.core.range","exfn.parser/replace-macro-args","macro-line","regex","cljs.core/re-pattern","clojure.string.join","cljs.core/keys","clojure.string/replace","exfn.parser/expand","macro","cljs.core.partial","exfn.parser/macro-expand-line","macro-call","cljs.core/List","exfn.parser/macro-expand-code","code","cljs.core.mapcat","exfn.parser/parse","asm","clojure.string/split-lines","p1__34181#","clojure.string/triml","p1__34182#","p1__34183#"],"sourcesContent":["(ns exfn.parser\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn is-register? [x]\r\n  (boolean (str/starts-with? x \":\")))\r\n\r\n(defn get-value [x]\r\n  (if (is-register? x)\r\n    (keyword (subs x 1))\r\n    x))\r\n\r\n(defn parse-msg [instruction]\r\n  (into [(keyword (subs instruction 0 3))]\r\n        (let [input (map identity (subs instruction 4))]\r\n          (loop [to-parse input\r\n                 res []\r\n                 in-quote? false\r\n                 current-string \"\"]\r\n            (let [i (first to-parse)]\r\n              (if (empty? to-parse)\r\n                (conj res (get-value current-string))\r\n                (cond\r\n                  (and in-quote? (= i \\'))\r\n                  (recur (rest to-parse) (conj res current-string) false \"\")\r\n\r\n                  (and in-quote? (not= i \\'))\r\n                  (recur (rest to-parse) res in-quote? (str current-string (str i)))\r\n\r\n                  (and (not in-quote?) (= i \\'))\r\n                  (recur (rest to-parse) (if (= \"\" current-string)\r\n                                           res\r\n                                           (conj res (get-value current-string))) true \"\")\r\n\r\n                  (and (not in-quote?) (= i \\space))\r\n                  (recur (rest to-parse) res in-quote? current-string)\r\n\r\n                  (and (not in-quote?) (= i \\;))\r\n                  (conj res (get-value current-string))\r\n\r\n                  :else\r\n                  (recur (rest to-parse) res in-quote? (str current-string (str i))))))))))\r\n\r\n(defn format-arg [arg]\r\n  (cond (is-register? arg)\r\n        (keyword (subs arg 1))\r\n\r\n        (re-find #\"(\\d+)\" arg)\r\n        (js/Number arg)\r\n\r\n        (or (str/starts-with? arg \"'\") (str/starts-with? arg \"`\"))\r\n        (subs arg 1 (dec (count arg)))\r\n\r\n        :else\r\n        (keyword arg)))\r\n\r\n(defn format-arguments [[instruction arg1 arg2]]\r\n  (cond-> [(keyword instruction)]\r\n    arg1 (conj (format-arg arg1))\r\n    (and (some? arg2) (not= \"\" arg2)) (conj (format-arg arg2))))\r\n\r\n;; ==============================================================================================\r\n;; A line will look like this:\r\n;;\r\n;; instruction arg1 arg2\r\n;; arg2 is optional.\r\n;;\r\n;; e.g.\r\n;; mov :a :b\r\n;; mov :a 'hello, world'\r\n;; mov :a 555\r\n;; call foo\r\n;; prn 555\r\n;; foo:\r\n;; prn 'hello, world'\r\n;; cat 'hello ' 'world'\r\n;; ret\r\n;; pop :x\r\n;; push :x\r\n;; push `hello, world 'bar', quax`\r\n;; push `hello, world \"bar\", quax`\r\n;; push 555\r\n;;\r\n;; if arg starts with a : it's a register.\r\n;; if arg starts with a ' it's a string.\r\n;; else arg is a number.\r\n;; ==============================================================================================\r\n(defn parse-line-of-code [line]\r\n  (if (re-find #\"\\w+:$\" line)\r\n    [:label (keyword (subs line 0 (dec (count line))))]\r\n    (let [instruction (first (re-find #\"^(\\w+)\" line))\r\n          args (subs line (inc (count instruction)))\r\n          first-arg (cond\r\n                      ; first argument is a register\r\n                      (str/starts-with? args \":\")\r\n                      (->> args\r\n                           (re-find #\"^(\\:\\w+)\")\r\n                           (first))\r\n\r\n                      ; first argument is a string\r\n                      (str/starts-with? args \"`\")\r\n                      (first (re-find #\"([`])(?:(?=(\\\\?))\\2.)*?\\1\" args))\r\n\r\n                      ; first argument is a string\r\n                      (str/starts-with? args \"'\")\r\n                      (first (re-find #\"(['])(?:(?=(\\\\?))\\2.)*?\\1\" args))\r\n\r\n                      ; first argument is a number.\r\n                      (re-find #\"^\\d\" args)\r\n                      (first (re-find #\"(\\d+)\" args))\r\n\r\n                      ; first argument is a label\r\n                      :else\r\n                      (first (re-find #\"(\\w+)\" args)))\r\n          \r\n          second-arg (str/trim (subs args (count first-arg)))]\r\n      (-> (cond (and (nil? first-arg) (= second-arg \"\"))\r\n                [instruction]\r\n                (and first-arg (= second-arg \"\"))\r\n                [instruction first-arg]\r\n                :else\r\n                [instruction first-arg second-arg])\r\n          (format-arguments)))))\r\n\r\n(comment (parse-line-of-code \"prn 'hello world'\")\r\n         (parse-line-of-code \"prn 555\")\r\n         (parse-line-of-code \"call foo\")\r\n         (parse-line-of-code \"foo:\")\r\n         (parse-line-of-code \"mov :a :b\")\r\n         (parse-line-of-code \"push `abc 'bar' quax`\")\r\n         (parse-line-of-code \"cat 'hello ' 'world'\")\r\n         (parse-line-of-code \"cat `foo 'bar' quax` 'world'\")\r\n         (parse-line-of-code \"mov :a 555\")\r\n         (parse-line-of-code \"mov :a 'foo, 'bar', quax'\")\r\n         (parse-line-of-code \"ret\"))\r\n\r\n(defn scrub-comments [s]\r\n  (if (and (not (str/starts-with? s \"msg\"))\r\n           (str/includes? s \";\"))\r\n    (str/trimr (subs s 0 (str/index-of s \";\")))\r\n    s))\r\n\r\n;; ==============================================================================================\r\n;; Code sections. Code sections are .macro and .code, .macro must come before .code\r\n;;\r\n;; e.g.\r\n;;\r\n;; .macros  << macro section starts\r\n;;    %square-and-sum << a macro name starts with %\r\n;;       mul %1 %1\r\n;;       mul %2 %2\r\n;;       add %1 %2\r\n;;    %end            << a macro ends with %end\r\n;;    %add-ten\r\n;;       add %1 10\r\n;;    %end\r\n;; .code    << macro section ends\r\n;;    mov :a 2\r\n;;    mov :b 5\r\n;;    square-and-sum (:a, :b) << macro call that needs expanded.\r\n;;    add-ten (:a)\r\n;; ==============================================================================================\r\n\r\n;; ==============================================================================================\r\n;; Parse the macro section.\r\n;; A macro section is the first section in the code\r\n;; It starts with .macros and finishes with .code\r\n;; \r\n;; Input: source code (split into lines and width code comments scrubbed, lines trimmed etc)\r\n;; Output: A map where the key is the macro name, and the body is the collection\r\n;;         of macro instructions that need arguments replaced. e.g.\r\n;;         {\"square-and-sum\" (\"mul %1 %1\" \"mul %2 %2\" \"add %1 %2\"), \"add-ten\" (\"add %1 10\")}\r\n;; ==============================================================================================\r\n(defn get-macros [source]\r\n  (let [macro-start (.indexOf source \".macros\")\r\n        macro-end (.indexOf source \".code\")\r\n        macros (->> source\r\n                    (drop (inc macro-start))\r\n                    (take (- (dec macro-end) macro-start))\r\n                    (partition-by (fn [n] (= n \"%end\")))\r\n                    (remove #(= '(\"%end\") %)))]\r\n    (zipmap (->> (map first macros)\r\n                 (map #(subs % 1)))\r\n            (map rest macros))))\r\n\r\n;; ==============================================================================================\r\n;; Parse the code section.\r\n;; The code section starts with .code and finishes either with .data or the end of the source string\r\n;; Input: source code (split into lines and width code comments scrubbed, lines trimmed etc)\r\n;; Output e.g. A collection of the lines of the source. e.g.\r\n;;        (\"mov :a 2\" \"mov :b 5\" \"square-and-sum(:a, :b)\" \"add-ten (:a)\")\r\n;; ==============================================================================================\r\n(defn get-code [source] \r\n  (let [code-start (.indexOf source \".code\")\r\n        data-start (.indexOf source \".data\")\r\n        code-end (if (= -1 data-start) (count source) data-start)]\r\n    (->> source\r\n         (drop (inc code-start))\r\n         (take (- (dec code-end) code-start)))))\r\n\r\n;; ==============================================================================================\r\n;; \r\n;; ==============================================================================================\r\n(defn is-macro-call? [macro-names line]\r\n  (first (filter #(str/starts-with? line %) macro-names)))\r\n\r\n;; TODO: This needs to return a map\r\n;; e.g. {\"%1\" \":a\", \"%2\" \":b\"}\r\n(defn get-args [line]\r\n  (let [args (->> (str/split (->> (re-seq #\"\\((.*?)\\)\" line)\r\n                                  (first)\r\n                                  (rest)\r\n                                  (first)) \",\")\r\n                  (remove #(= \"\" %))\r\n                  (map str/trim))]\r\n     ;; what if args is empty.\r\n    (when (seq args)\r\n      (zipmap (->> (range 1 (inc (count args)))\r\n                   (map (fn [n] (str \"%\" n))))\r\n              args))))\r\n\r\n(defn replace-macro-args [args macro-line]\r\n  (let [regex (re-pattern (str/join \"|\" (keys args)))]\r\n    (str/replace macro-line regex args)))\r\n\r\n(defn expand\r\n  [line macro] ;\r\n  (let [args (get-args line)]\r\n    (if args\r\n      (map (partial replace-macro-args args) macro)\r\n      macro)))\r\n\r\n(defn macro-expand-line [macros line]\r\n  (let [macro-call (is-macro-call? (keys macros) line)]\r\n    (if macro-call\r\n      (expand line (macros macro-call)) ; need to pass the macro that matched.\r\n      (list line))))\r\n\r\n(defn macro-expand-code [code macros]\r\n  (mapcat (partial macro-expand-line macros) code))\r\n\r\n(defn parse [asm]\r\n  (let [source (->> (str/split-lines asm)\r\n                    (map #(str/trimr (str/triml %)))\r\n                    (map scrub-comments)\r\n                    (remove #(= \"\" %))\r\n                    (remove #(str/starts-with? % \";\")))\r\n        macros (get-macros source)\r\n        code (get-code source)]\r\n    (->> (macro-expand-code code macros)\r\n         (map parse-line-of-code))))\r\n\r\n(comment\r\n  (let [asm    \".macros\r\n                %square-and-sum\r\n                   mul %1 %1\r\n                   mul %2 %2\r\n                   add %1 %2\r\n                %end\r\n                %add-ten\r\n                   add %1 10\r\n                %end\r\n                .code\r\n                   mov :a 2\r\n                   mov :b 5\r\n                   square-and-sum(:a, :b)\r\n                   add-ten (:a)\"]\r\n    (parse asm)))"]}