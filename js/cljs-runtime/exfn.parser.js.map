{"version":3,"sources":["exfn/parser.cljs"],"mappings":"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","names":["exfn.parser/is-register?","x","cljs.core/re-find","exfn.parser/get-value","cljs.core.keyword","js/Number","exfn.parser/parse-msg","instruction","cljs.core.into","cljs.core.subs","input","cljs.core.map","cljs.core/identity","to-parse","res","in-quote?","current-string","i","cljs.core/first","cljs.core/empty?","cljs.core.conj","and__4115__auto__","cljs.core._EQ_","cljs.core/rest","cljs.core.not_EQ_","cljs.core/not","exfn.parser/drop-last-char","s","cljs.core/count","exfn.parser/to-keywords","instructions","vec__30010","cljs.core.nth","op1","op2","clojure.string.split","clojure.string/ends-with?","G__30013","exfn.parser/scrub-comments","clojure.string/starts-with?","clojure.string/includes?","clojure.string/trimr","clojure.string.index_of","exfn.parser/parse","asm","clojure.string/split-lines","p1__30014#","clojure.string/triml","p1__30015#","cljs.core.remove","p1__30016#"],"sourcesContent":["(ns exfn.parser\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn is-register? [x]\r\n  (nil? (re-find #\"^[\\+\\-]?\\d*\\.?[\\+\\-]?\\d*$\" x)))\r\n\r\n(defn get-value [x]\r\n  (if (is-register? x)\r\n    (keyword x)\r\n    (js/Number x)))\r\n\r\n(defn parse-msg [instruction]\r\n  (into [(keyword (subs instruction 0 3))]\r\n        (let [input (map identity (subs instruction 4))]\r\n          (loop [to-parse input\r\n                 res []\r\n                 in-quote? false\r\n                 current-string \"\"]\r\n            (let [i (first to-parse)]\r\n              (if (empty? to-parse)\r\n                (conj res (get-value current-string))\r\n                (cond\r\n                  (and in-quote? (= i \\'))\r\n                  (recur (rest to-parse) (conj res current-string) false \"\")\r\n\r\n                  (and in-quote? (not= i \\'))\r\n                  (recur (rest to-parse) res in-quote? (str current-string (str i)))\r\n\r\n                  (and (not in-quote?) (= i \\'))\r\n                  (recur (rest to-parse) (if (= \"\" current-string)\r\n                                           res\r\n                                           (conj res (get-value current-string))) true \"\")\r\n\r\n                  (and (not in-quote?) (= i \\space))\r\n                  (recur (rest to-parse) res in-quote? current-string)\r\n\r\n                  (and (not in-quote?) (= i \\;))\r\n                  (conj res (get-value current-string))\r\n\r\n                  :else\r\n                  (recur (rest to-parse) res in-quote? (str current-string (str i))))))))))\r\n\r\n(defn- drop-last-char [s]\r\n  (subs s 0 (dec (count s))))\r\n\r\n(defn to-keywords [instructions]\r\n  (let [[instruction op1 op2] (str/split instructions #\" \")]\r\n    (cond (= \"msg\" instruction)\r\n          (parse-msg instructions)\r\n\r\n          (and (nil? op1) (nil? op2) (str/ends-with? instruction \":\"))\r\n          [:label (keyword (drop-last-char instruction))]\r\n\r\n          :else\r\n          (cond-> [(keyword instruction)]\r\n            (not (nil? op1)) (conj (get-value op1))\r\n            (not (nil? op2)) (conj (get-value op2))))))\r\n\r\n(defn scrub-comments [s]\r\n  (if (and (not (str/starts-with? s \"msg\"))\r\n           (str/includes? s \";\"))\r\n    (str/trimr (subs s 0 (str/index-of s \";\")))\r\n    s))\r\n\r\n(defn parse [asm]\r\n  (->> (str/split-lines asm)\r\n       (map #(str/trimr (str/triml %)))\r\n       (map scrub-comments)\r\n       (remove #(= \"\" %))\r\n       (remove #(str/starts-with? % \";\"))\r\n       (map to-keywords)))"]}