{"version":3,"sources":["exfn/interpreter.cljs"],"mappings":"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","names":["exfn.interpreter/get-parity","n","cljs.core/even?","p1__106221#","cljs.core.filter","cljs.core._EQ_","cljs.core/count","exfn.interpreter/get-value","registers","x","cljs.core/Keyword","cljs.core.get","exfn.interpreter/add-error","memory","err-no","err-msg","cljs.core.update_in","cljs.core/assoc","exfn.interpreter/cmp-jump-predicates","jump-instruction","pred__106222","expr__106223","js/Error","cljs.core/=","exfn.interpreter/build-symbol-table","asm","cljs.core.reduce","p__106225","vec__106226","cljs.core.nth","a","i","ix","cljs.core/first","cljs.core.assoc","cljs.core/second","cljs.core.map","cljs.core/vector","cljs.core.range","exfn.interpreter/append-output","existing","new","and__4115__auto__","cljs.core/not","p__106229","p__106230","map__106231","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","vec__106232","exfn.interpreter/mov","b","cljs.core.keyword","cljs.core.update","p__106236","map__106237","exfn.interpreter/prnout","output","args","exfn.interpreter/get-math-fun","f","pred__106239","expr__106240","cljs.core/+","cljs.core/-","cljs.core/quot","cljs.core/*","cljs.core/bit-xor","cljs.core/bit-and","cljs.core/bit-or","p__106242","p__106243","map__106244","vec__106245","exfn.interpreter/math-func","instruction","av","bv","result","fexpr__106249","p__106250","p__106251","map__106252","vec__106253","exfn.interpreter/str-cat","p__106257","p__106258","map__106259","vec__106260","exfn.interpreter/increment","target","p__106264","p__106265","map__106266","vec__106267","exfn.interpreter/decrement","p__106271","p__106272","map__106273","vec__106274","exfn.interpreter/bitnot","p__106278","p__106279","map__106280","vec__106281","exfn.interpreter/strlen","v","p__106285","p__106286","map__106287","vec__106288","exfn.interpreter/jnz","eip","jmp","p__106292","p__106293","map__106294","vec__106295","exfn.interpreter/jz","p__106299","p__106300","map__106301","vec__106302","exfn.interpreter/jmp","symbol-table","p__106306","p__106307","map__106308","vec__106309","exfn.interpreter/cmp","cljs.core/assoc-in","p__106313","p__106314","map__106315","vec__106316","exfn.interpreter/cmp-jmp","internal-registers","jump-type","cmp","valid-predicates","G__106320","p__106321","p__106322","map__106323","vec__106324","exfn.interpreter/call","G__106328","cljs.core/conj","p__106329","map__106330","exfn.interpreter/ret","eip-stack","cljs.core/peek","cljs.core/pop","p__106332","p__106333","map__106334","vec__106335","exfn.interpreter/pop-stack","stack","cljs.core/empty?","cljs.core/identity","p__106339","map__106340","exfn.interpreter/push","p__106342","map__106343","exfn.interpreter/rep","cljs.core/seq","rep-ctr","exfn.interpreter/cer","cljs.core/dissoc","p__106345","map__106346","exfn.interpreter/rp","counter","cljs.core/inc","exfn.interpreter/get-conditional-repeat-function","pred__106348","expr__106349","cljs.core/zero?","p__106351","p__106352","map__106353","vec__106354","exfn.interpreter/conditional-repeat","condition","exfn.interpreter/get-termination-cause","pred__106358","expr__106359","p__106361","map__106362","exfn.interpreter/interpret","instructions","vec__106364","seq__106365","first__106366","cljs.core/next","fexpr__106367","fexpr__106368","map__106369","map__106371","map__106373","fexpr__106375","map__106376","fexpr__106378","terminated?","finished?","G__106379"],"sourcesContent":["(ns exfn.interpreter)\n\n;;=======================================================================================================\n;; Returns 1 if n has an even number of 1s in its binary representation, otherwise 0.\n;;=======================================================================================================\n(defn get-parity [n]\n  (if (even? (-> (filter #(= \"1\" %) (.toString n 2)) count)) 1 0))\n\n;;=======================================================================================================\n;; if x is a register, returns the value from the registers.\n;; Otherwise return x (as it's a value not a register).\n;;=======================================================================================================\n(defn get-value [registers x]\n  (if (keyword? x)\n    (get registers x)\n    x))\n\n;;=======================================================================================================\n;; An error is an error number and an error message.\n;; This methods add both to the memory.\n;;=======================================================================================================\n(defn add-error [memory err-no err-msg]\n  (-> memory\n      (update-in [:internal-registers] assoc :err err-no)\n      (update-in [:internal-registers] assoc :err-msg err-msg)))\n\n;;=======================================================================================================\n;; Return the predicate for cmp jumps that we want the jump check to satisfy.\n;;\n;; If jump is jge (jump if greater than or equal), then valid predicates for cmp are :eq (equal to) or :gt (greater than)\n;; If jump is jge (jump if greater than), then valid predicates for cmp are :gt (greater than)\n;; If jump is jne (jump if not equal), then valid predicates for cmp are :gt (greater than) or :lt (less than)\n;; If jump is je (jump if equal), then valid predicates for cmp are :eq (equal to)\n;; If jump is jle (jump if less than or equal), then valid predicates for cmp are :eq (equal to) or :lt (less than)\n;; If jump is jl (jump if less than), then valid predicates for cmp are :lt (less than)\n;;=======================================================================================================\n(defn cmp-jump-predicates [jump-instruction]\n  (condp = jump-instruction\n    :jge #{:eq :gt}\n    :jg  #{:gt}\n    :jne #{:lt :gt}\n    :je  #{:eq}\n    :jle #{:eq :lt}\n    :jl  #{:lt}))\n\n;;=======================================================================================================\n;; Builds the symbol table for jump targets\n;; A jump target is a label of form foo:\n;;=======================================================================================================\n(defn build-symbol-table [asm]\n  (reduce (fn [a [i ix]]\n            (if (= (first ix) :label)\n              (assoc a (second ix) i)\n              a))\n          {}\n          (map vector (range) asm)))\n\n;;=======================================================================================================\n;; Update the existing output with the new line of output.\n;;=======================================================================================================\n(defn append-output [existing new]\n  (cond (and existing new)\n        (str existing \"\\n\" new)\n\n        (and existing (not new))\n        existing\n\n        :else\n        new))\n\n;;=======================================================================================================\n;; MOV instruction\n;;\n;; Syntax:\n;; mov a b\n;;\n;; Moves the contents of `b` (value or register) into register `a`\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn mov [{:keys [registers] :as memory} [a b]]\n  (if (keyword a)\n    (-> memory\n        (update :registers assoc a (get-value registers b)))\n    (add-error memory 101 \"First argument to mov must be a register.\")))\n\n;;=======================================================================================================\n;; PRN instruction\n;;\n;; Syntax:\n;; prn a\n;;\n;; Appends the contents of a (string / number / register) to output\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn prnout [{:keys [output registers] :as memory} args]\n  (-> memory\n      (assoc :output (append-output output (get-value registers (first args))))))\n\n;;=======================================================================================================\n;; Gets the function to apply for the given instruction f.\n;;=======================================================================================================\n(defn get-math-fun [f]\n  (condp = f\n    :add +\n    :sub -\n    :div quot\n    :mul *\n    :xor bit-xor\n    :and bit-and\n    :or bit-or))\n\n;;=======================================================================================================\n;; math instruction, covers add, sub, div, mul, xor, and, or\n;;\n;; Syntax:\n;; instruction a b\n;;\n;; Performs the math operation for instruction passing `a` and `b` as args. Stores the result in `a`.\n;; Sets the parity flag if result in `a` has even number of bits in its binary representation.\n;;=======================================================================================================\n(defn math-func [instruction {:keys [registers] :as memory} [a b]]\n  (let [av (get-value registers a)\n        bv (get-value registers b)]\n    (cond\n      (not (keyword? a))\n      (add-error memory 202 (str \"First argument to math operation \" instruction \" must be a register. Invalid {\" a \"}\"))\n\n      (or (not (number? av)) (not (number? bv)))\n      (add-error memory 201 (str \"Math operation \" instruction \" performed on non number arguments.\" a \" and \" b))\n\n      :else\n      (let [result ((get-math-fun instruction) av bv)]\n        (-> memory\n            (update-in [:registers] assoc a result)\n            (update-in [:internal-registers] assoc :par (get-parity result)))))))\n\n;;=======================================================================================================\n;; cat instruction\n;;\n;; Syntax:\n;; cat a b\n;;\n;; Concatentates two strings `a` (registers) and `b` (registers or string literal), stores the result in `a`\n;; e.g.\n;; \n;;     mov :a 'hello '\n;;     mov :b 'world'\n;;     cat :a :b\n;; Will leave :a 'hello world'\n;;\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn str-cat [{:keys [registers] :as memory} [a b]]\n  (-> memory\n      (update-in [:registers] assoc a (str (get-value registers a) (get-value registers b)))))\n\n;;=======================================================================================================\n;; inc instruction\n;;\n;; Syntax:\n;; inc a\n;;\n;; Increments the value in registers `a`, stores the incremented value in `a`\n;; e.g.\n;; \n;;     mov :a 5\n;;     inc :a\n;; Will leave :a = 6\n;;\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn increment [{:keys [registers] :as memory} [a]]\n  (let [target (get-value registers a)]\n    (if (number? target)\n      (-> memory\n          (update-in [:registers] assoc a (inc target))\n          (update-in [:internal-registers] assoc :par (get-parity (inc target))))\n      (add-error memory 203 \"Can only increment numbers.\"))))\n\n;;=======================================================================================================\n;; dec instruction\n;;\n;; Syntax:\n;; dec a\n;;\n;; Decrements the value in registers `a`, stores the decremented value in `a`\n;; e.g.\n;; \n;;     mov :a 5\n;;     dec :a\n;; Will leave :a = 4\n;;\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn decrement [{:keys [registers] :as memory} [a]]\n  (let [target (get-value registers a)]\n    (if (number? target)\n      (-> memory\n          (update-in [:registers] assoc a (dec target))\n          (update-in [:internal-registers] assoc :par (get-parity (dec target))))\n      (add-error memory 204 \"Can only decrement numbers.\"))))\n\n;;=======================================================================================================\n;; not instruction\n;;\n;; Syntax:\n;; not a\n;;\n;; Performs bit-not on 'a', stores the result in 'a'\n;; e.g.\n;; \n;;     mov :a 5\n;;     not :a\n;; Will leave :a = -6\n;;=======================================================================================================\n(defn bitnot [{:keys [registers] :as memory} [a]]\n  (if (number? (get-value registers a))\n    (let [result (bit-not (get-value registers a))]\n      (-> memory\n          (update-in [:registers] assoc a result)\n          (update-in [:internal-registers] assoc :par (get-parity result))\n          (assoc :last-edit-register a)))\n    (add-error memory 205 \"not instruction argument not a number.\")))\n\n;;=======================================================================================================\n;; strlen\n;;\n;; Syntax:\n;; strlen a b\n;;\n;; Stores the length of string `b` in `a`\n;;=======================================================================================================\n(defn strlen [{:keys [registers] :as memory} [a b]]\n  (let [v (get-value registers b)]\n    (if (string? v)\n      (-> memory\n          (update-in [:registers] assoc a (count v)))\n      (add-error memory 301 \"len passed non-string argument.\"))))\n\n;;=======================================================================================================\n;; jnz instruction\n;;\n;; Syntax:\n;; jnz a b\n;;\n;; Jumps `b` (number or register) instructions (positive or negative) if `a` (number or register) is not\n;; zero.\n;; If it is zero, then increments the eip.\n;;=======================================================================================================\n(defn jnz [{:keys [eip registers] :as memory} [a b]]\n  (let [a (get-value registers a)\n        b (get-value registers b)\n        jmp (if (zero? a) 1 b)]\n    (assoc memory :eip (+ eip jmp))))\n\n;;=======================================================================================================\n;; jz instruction\n;;\n;; Syntax:\n;; jz a b\n;;\n;; Jumps `b` (number or register) instructions (positive or negative) if `a` (number or register) is\n;; zero.\n;; If it is not zero, then increments the eip.\n;;=======================================================================================================\n(defn jz [{:keys [eip registers] :as memory} [a b]]\n  (let [a (get-value registers a)\n        b (get-value registers b)\n        jmp (if (not (zero? a)) 1 b)]\n    (assoc memory :eip (+ eip jmp))))\n\n;;=======================================================================================================\n;; jmp instruction\n;;\n;; Syntax:\n;; jmp a\n;;\n;; Moves the execution pointer to the label `a`.\n;; It finds the address for `a` by loking up `a` in the symbol table.\n;;=======================================================================================================\n(defn jmp [{:keys [symbol-table] :as memory} [a]]\n  (assoc memory :eip (get symbol-table a -2)))\n\n;;=======================================================================================================\n;; cmp instruction\n;;\n;; Syntax:\n;; cmp a b (a and b can be values or registers.)\n;;\n;; Compares `a` and `b` and stores the result in the :cmp internal register.\n;; A comparison can be :eq (a = b)\n;;                     :gt (a > b)\n;;                     :lt (a < b)\n;; Increments the eip\n;;=======================================================================================================\n(defn cmp [{:keys [registers] :as memory} [a b]]\n  (let [av (get-value registers a)\n        bv (get-value registers b)]\n    (-> memory\n        (assoc-in [:internal-registers :cmp] (cond (= av bv) :eq\n                                                   (> av bv) :gt\n                                                   (< av bv) :lt)))))\n\n;;=======================================================================================================\n;; Handles jne, jg, jl, jle, jge, je\n;;\n;; jne - jumps to label if previous cmp call was not equal (greater-than or less-than)\n;; je  - jumps to labe if previous cmp call was equal\n;; jg  - jumps to label if previous cmp call was greater-than\n;; jge - jumps to label if previous cmp call was greater-than or equal-to\n;; jl  - jumps to label if previous cmp call was less-than\n;; jle - jumps to label if previous cmp call was less-than or equal-to\n;;\n;; Syntax (syntax is same for all the supported jumps):\n;; jne foo\n;; \n;; jumps to the label foo if the result of the previous cmp call fufills jmp predicate\n;;=======================================================================================================\n(defn cmp-jmp [{:keys [eip internal-registers symbol-table] :as memory} jump-type [a]]\n  (let [cmp              (:cmp internal-registers)\n        valid-predicates (cmp-jump-predicates jump-type)]\n    (assoc memory :eip (if (valid-predicates cmp)\n                         (symbol-table (keyword a))\n                         (inc eip)))))\n\n;;=======================================================================================================\n;; call instruction\n;;\n;; Syntax:\n;; call foo\n;;\n;; Moves eip pointer to the label foo.\n;; Pushes the eip at the call site to the eip-stack as a ret target.\n;;=======================================================================================================\n(defn call [{:keys [eip symbol-table] :as memory} [a]]\n  (let [target (symbol-table (keyword a))]\n    (if target\n      (-> memory\n          (update :eip-stack conj eip)\n          (assoc :eip target))\n      (-> memory\n          (assoc :eip -3)))))\n\n;;=======================================================================================================\n;; ret instruction\n;;\n;; Syntax:\n;; ret\n;;\n;; Moves eip pointer to the top eip on the eip-stack\n;;=======================================================================================================\n(defn ret [{:keys [eip-stack] :as memory}]\n  (let [target (peek eip-stack)]\n    (if target\n      (-> memory\n          (assoc :eip (inc (peek eip-stack)))\n          (update :eip-stack pop))\n      (-> memory\n          (assoc :eip -4)))))\n\n\n\n;;=======================================================================================================\n;; pop instruction\n;;\n;; Syntax:\n;; pop a\n;;\n;; Pops a value off the stack into register a.\n;; Increments the eip\n;;\n;; ERR: Will set :err field to \"Popped empty stack\" if stack is empty.\n;;=======================================================================================================\n(defn pop-stack [{:keys [stack] :as memory} [a]]\n  (cond (empty? stack)\n        (add-error memory 401 \"Popped empty stack.\")\n\n        (not (keyword? a))\n        (add-error memory 402 \"Invalid pop target.\")\n\n        :else\n        (-> memory\n            (assoc-in [:registers a] (peek stack))\n            (update :stack (if (empty? stack) identity pop))\n            (assoc :last-edit-register a))))\n\n;;=======================================================================================================\n;; push instruction\n;;\n;; Syntax:\n;; push a\n;;\n;; Pushes a (register or value) onto the stack.\n;;=======================================================================================================\n(defn push [{:keys [registers] :as memory} args]\n  (let [x (get-value registers (first args))]\n    (-> memory\n        (update :stack conj x))))\n\n;;=======================================================================================================\n;; rep instruction\n;;\n;; Syntax:\n;; rep a\n;; rep\n;;\n;; If a value `a` is supplied (number or register) then rep sets a rep-counter and pushes it to the\n;; rp-stack, also pushes current eip to eip-stack (in this case it is an rp target)\n;; If no args are supplied, it only pushes the current eip to the eip-stack (in this case its a conditional\n;; rp target).\n;; `a` should be greater than zero. If it's passed zero, it will still run through the loop once.\n;;=======================================================================================================\n(defn rep [{:keys [eip registers] :as memory} args]\n  (if (seq args)\n    (let [rep-ctr (get-value registers (first args))]\n      (if (number? rep-ctr)\n        (-> memory\n            (update-in [:rep-counters-stack] conj rep-ctr)\n            (update-in [:eip-stack] conj eip))\n        (add-error memory 501 (str \"Invalid argument {\" rep-ctr \"} to rep\"))))\n    (update-in memory [:eip-stack] conj eip)))\n\n;;=======================================================================================================\n;; cer instruction.\n;;\n;; Clears the error flags in :internal-registers\n;;   :err\n;;   :err-msg\n;;=======================================================================================================\n(defn cer [memory]\n  (if (:internal-registers memory)\n    (-> memory\n        (update-in [:internal-registers] dissoc :err)\n        (update-in [:internal-registers] dissoc :err-msg))\n    memory))\n\n;;=======================================================================================================\n;; rp instruction\n;;\n;; Syntax:\n;; rp\n;;\n;; Decrements the top item on the RP stack. If it would be zero after decrementing then it increments the\n;; eip. Otherwise it sets eip to the top value of the eip-stack.\n;;\n;; Errors:\n;; If the rep counters stack is empty the error flag is set to 502 and error message is set to\n;; \"rp called with empty rep counters stack\"\n;;=======================================================================================================\n(defn rp [{:keys [eip-stack] :as memory}]\n  (if (empty? (memory :rep-counters-stack))\n    (add-error memory 502 \"rp called with empty rep counters stack\")\n    (let [counter (peek (memory :rep-counters-stack))]\n      (if (<= counter 1) ; decrementing would reduce it to zero, so increment eip and pop the rp-stack.\n        (-> memory\n            (update :rep-counters-stack pop)\n            (update :eip-stack pop)\n            (update :eip inc))\n        (-> memory ; otherwise decrement the top item on the rp-stack and set eip to top value on eip-stack.\n            (update :rep-counters-stack pop)\n            (update :rep-counters-stack conj (dec counter))\n            (assoc :eip (inc (peek eip-stack))))))))\n\n;;=======================================================================================================\n;; Get the conditional function for the r*z instructions.\n;;=======================================================================================================\n(defn get-conditional-repeat-function [f]\n  (condp = f\n    :rz (fn [x] (not (zero? x)))\n    :rnz zero?\n    :rlez (fn [x] (> x 0))\n    :rlz (fn [x] (>= x 0))\n    :rgz (fn [x] (<= x 0))\n    :rgez (fn [x] (< x 0))))\n\n;;=======================================================================================================\n;; r*z conditional repeats\n;;\n;; Syntax:\n;; rz a      Repeats until `a` is zero.\n;; rnz a     Repeats until `a` is not zero.\n;; rlez a    Repeat until `a` is less than or equal to zero.\n;; rgez a    Repeat until `a` is greater than or equal to zero.\n;; rgz a     Repeat until `a` is greater than zero.\n;; rlz a     Repeat until `a` is less than zero.\n;;\n;; Errors:\n;; If the argument to r*z is not a number then eip is icremented and error flag is set to 503 with\n;; error message: {instruction} called with non numeric argument.\n;;=======================================================================================================\n(defn conditional-repeat [{:keys [eip-stack registers] :as memory} instruction [a]]\n  (let [condition (get-conditional-repeat-function instruction)\n        v (get-value registers a)]\n    (if (number? v)\n      (if (condition v)\n        (-> memory\n            (assoc :eip (inc (peek eip-stack))))\n        (-> memory\n            (update :eip inc)\n            (update :eip-stack pop)))\n      (-> memory\n          (add-error 503 (str instruction \" called with non numeric argument.\"))\n          (update :eip inc)))))\n\n;;=======================================================================================================\n;; if eip = -1: jump past last instruction  \n;;    eip = -2: jump to non existent label.\n;;=======================================================================================================\n(defn get-termination-cause [eip]\n  (condp = eip\n    -1 \"Terminated: EIP jumped past last instruction.\"\n    -2 \"Terminated: Jump to non existant label.\"\n    -3 \"Called non-existent function.\"\n    -4 \"Encoutered ret, with no value on eip stack.\"\n    \"Program exited without :end\"))\n\n;;=======================================================================================================\n;; The interpreter.\n;;=======================================================================================================\n(defn interpret [instructions {:keys [eip] :as memory}]\n  (let [[instruction & args] (nth instructions eip)\n        memory (cond (= :mov instruction)\n                     (-> (mov memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (#{:add :sub :mul :div :xor :and :or} instruction)\n                     (-> (math-func instruction memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :cat instruction)\n                     (-> (str-cat memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :cer instruction)\n                     (-> (cer memory)\n                         (update :eip inc))\n\n                     (= :inc instruction)\n                     (-> (increment memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :dec instruction)\n                     (-> (decrement memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :not instruction)\n                     (-> (bitnot memory args)\n                         (update :eip inc))\n\n                     (= :len instruction)\n                     (-> (strlen memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (#{:nop :label} instruction)\n                     (update memory :eip inc)\n\n                     (= :prn instruction)\n                     (-> (prnout memory args)\n                         (update :eip inc))\n\n                     (= :jnz instruction)\n                     (let [{:keys [eip] :as memory} (jnz memory args)]\n                       (if (> eip (count instructions))\n                         (assoc memory :eip -1)\n                         memory))\n\n                     (= :jz instruction)\n                     (let [{:keys [eip] :as memory} (jz memory args)]\n                       (if (> eip (count instructions))\n                         (assoc memory :eip -1)\n                         memory))\n\n                     (= :jmp instruction)\n                     (let [{:keys [eip] :as memory} (jmp memory args)]\n                       (if (> eip (count instructions))\n                         (assoc memory :eip -1)\n                         memory))\n\n                     (= :cmp instruction)\n                     (-> memory\n                         (cmp args)\n                         (update :eip inc))\n\n                     (#{:jne :jg :je :jl :jle :jge} instruction)\n                     (let [{:keys [eip] :as memory} (cmp-jmp memory instruction args)]\n                       (if (> eip (count instructions))\n                         (assoc memory :eip -1)\n                         memory))\n\n                     (= :call instruction)\n                     (call memory args)\n\n                     (= :ret instruction)\n                     (ret memory)\n\n                     (= :push instruction)\n                     (-> memory\n                         (push args)\n                         (update :eip inc))\n\n                     (= :pop instruction)\n                     (-> memory\n                         (pop-stack args)\n                         (update :eip inc))\n\n                     (= :rep instruction)\n                     (-> memory\n                         (rep args)\n                         (update :eip inc))\n\n                     (= :rp instruction)\n                     (rp memory)\n\n                     (#{:rnz :rz :rgz :rlz :rgez :rlez} instruction)\n                     (conditional-repeat memory instruction args)\n\n                     :else\n                     memory)\n        terminated? (or (> (memory :eip) (dec (count instructions)))\n                       (neg? (memory :eip)))\n        finished? (= :end instruction)]\n    {:memory (cond-> memory\n               terminated? (assoc :output (append-output (memory :output) (get-termination-cause (memory :eip))))\n               finished?   (assoc :output (append-output (memory :output) \"Exited.\")))\n     :terminated? terminated?\n     :finished? (or finished? terminated?)}))"]}