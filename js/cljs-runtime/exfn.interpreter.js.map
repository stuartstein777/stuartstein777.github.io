{"version":3,"sources":["exfn/interpreter.cljs"],"mappings":"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","names":["exfn.interpreter/get-value","registers","x","cljs.core/Keyword","cljs.core.get","exfn.interpreter/cmp-jump-predicates","jump-instruction","pred__31145","expr__31146","js/Error","cljs.core/=","exfn.interpreter/build-symbol-table","asm","cljs.core.reduce","p__31152","vec__31153","cljs.core.nth","a","i","ix","cljs.core._EQ_","cljs.core/first","cljs.core.assoc","cljs.core/second","cljs.core.map","cljs.core/vector","cljs.core.range","exfn.interpreter/append-output","existing","new","and__4115__auto__","cljs.core/not","p__31157","p__31158","map__31159","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","vec__31160","exfn.interpreter/mov","memory","b","cljs.core.update_in","cljs.core/assoc","cljs.core.update","cljs.core/inc","p__31164","map__31168","exfn.interpreter/prnout","output","args","p__31172","p__31173","map__31174","vec__31175","exfn.interpreter/add","p__31179","p__31180","map__31181","vec__31182","exfn.interpreter/sub","p__31186","p__31187","map__31188","vec__31189","exfn.interpreter/mul","p__31195","p__31196","map__31197","vec__31198","exfn.interpreter/div","cljs.core/quot","p__31202","p__31203","map__31204","vec__31205","exfn.interpreter/xor","p__31209","p__31210","map__31211","vec__31212","exfn.interpreter/bitand","p__31219","p__31220","map__31221","vec__31222","exfn.interpreter/bitor","p__31242","p__31243","map__31248","vec__31249","exfn.interpreter/str-cat","p__31253","p__31254","map__31255","vec__31256","exfn.interpreter/increment","p__31260","p__31261","map__31262","vec__31263","exfn.interpreter/decrement","p__31267","p__31268","map__31269","vec__31270","exfn.interpreter/bitnot","exfn.interpreter/nop","p__31274","p__31275","map__31276","vec__31277","exfn.interpreter/strlen","cljs.core/count","p__31281","p__31282","map__31283","vec__31284","exfn.interpreter/jnz","eip","jmp","p__31288","p__31289","map__31290","vec__31291","exfn.interpreter/jmp","symbol-table","p__31295","p__31296","map__31297","vec__31298","exfn.interpreter/cmp","av","bv","cljs.core/assoc-in","p__31302","p__31303","map__31304","vec__31305","exfn.interpreter/cmp-jmp","internal-registers","jump-type","cmp","valid-predicates","cljs.core.prn","G__31309","cljs.core.keyword","p__31310","p__31311","map__31312","vec__31313","exfn.interpreter/call","target","G__31317","cljs.core/conj","p__31318","map__31319","exfn.interpreter/ret","eip-stack","cljs.core/peek","cljs.core/pop","p__31321","p__31322","map__31323","vec__31324","exfn.interpreter/pop-stack","stack","cljs.core/empty?","cljs.core/identity","p__31328","map__31329","exfn.interpreter/push","p__31331","map__31332","exfn.interpreter/rep","cljs.core/seq","p__31334","map__31335","exfn.interpreter/rp","counter","exfn.interpreter/get-conditional-repeat-function","f","pred__31337","expr__31338","cljs.core/zero?","p__31340","p__31341","map__31342","vec__31343","exfn.interpreter/conditional-repeat","instruction","condition","G__31347","p__31348","map__31349","exfn.interpreter/interpret","instructions","vec__31351","seq__31352","first__31353","cljs.core/next","fexpr__31354","fexpr__31355"],"sourcesContent":["(ns exfn.interpreter)\r\n\r\n;;=======================================================================================================\r\n;; if x is a register, returns the value from the registers.\r\n;; Otherwise return x (as it's a value not a register).\r\n;;=======================================================================================================\r\n(defn get-value [registers x]\r\n  (if (keyword? x)\r\n    (get registers x)\r\n    x))\r\n\r\n;;=======================================================================================================\r\n;; Return the predicate for cmp jumps that we want the jump check to satisfy.\r\n;;\r\n;; If jump is jge (jump if greater than or equal), then valid predicates for cmp are :eq (equal to) or :gt (greater than)\r\n;; If jump is jge (jump if greater than), then valid predicates for cmp are :gt (greater than)\r\n;; If jump is jne (jump if not equal), then valid predicates for cmp are :gt (greater than) or :lt (less than)\r\n;; If jump is je (jump if equal), then valid predicates for cmp are :eq (equal to)\r\n;; If jump is jle (jump if less than or equal), then valid predicates for cmp are :eq (equal to) or :lt (less than)\r\n;; If jump is jl (jump if less than), then valid predicates for cmp are :lt (less than)\r\n;;=======================================================================================================\r\n(defn cmp-jump-predicates [jump-instruction]\r\n  (condp = jump-instruction\r\n    :jge #{:eq :gt}\r\n    :jg  #{:gt}\r\n    :jne #{:lt :gt}\r\n    :je  #{:eq}\r\n    :jle #{:eq :lt}\r\n    :jl  #{:lt}))\r\n\r\n;;=======================================================================================================\r\n;; Builds the symbol table for jump targets\r\n;; A jump target is a label of form foo:\r\n;;=======================================================================================================\r\n(defn build-symbol-table [asm]\r\n  (reduce (fn [a [i ix]]\r\n            (if (= (first ix) :label)\r\n              (assoc a (second ix) i)\r\n              a))\r\n          {}\r\n          (map vector (range) asm)))\r\n\r\n;;=======================================================================================================\r\n;; Update the existing output with the new line of output.\r\n;;=======================================================================================================\r\n(defn append-output [existing new]\r\n  (cond (and existing new)\r\n        (str existing \"\\n\" new)\r\n\r\n        (and existing (not new))\r\n        existing\r\n\r\n        (= \"\" existing)\r\n        new))\r\n\r\n;;=======================================================================================================\r\n;; MOV instruction\r\n;;\r\n;; Syntax:\r\n;; mov a b\r\n;;\r\n;; Moves the contents of `b` (value or register) into register `a`\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn mov [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (get-value registers b))\r\n      (assoc :last-edit-register a)\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; PRN instruction\r\n;;\r\n;; Syntax:\r\n;; prn a\r\n;;\r\n;; Appends the contents of a (string / number / register) to output\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn prnout [{:keys [output registers] :as memory} args]\r\n  (-> memory\r\n      (assoc :output (append-output output (get-value registers (first args))))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; ADD instruction\r\n;;\r\n;; Syntax:\r\n;; add a b\r\n;;\r\n;; Adds `a` (register) and `b` (number or register) and stores the result in `a`\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn add [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (+ (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; SUB instruction\r\n;;\r\n;; Syntax:\r\n;; sub a b\r\n;;\r\n;; Subtracts `b` (number or register) from `a` (register) and stores the result in `a`\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn sub [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (- (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; MUL instruction\r\n;;\r\n;; Syntax:\r\n;; mul a b\r\n;;\r\n;; Multiplies `a` and `b` (number or register) and stores the result in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 10\r\n;;     mov :b 5\r\n;;     mul :a :b\r\n;; Will leave :a = 50\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn mul [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (* (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; DIV instruction\r\n;;\r\n;; Syntax:\r\n;; div a b\r\n;;\r\n;; Divides (Integer division) `a` and `b` (number or register) and stores the result in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 10\r\n;;     mov :b 5\r\n;;     div :a :b\r\n;; Will leave :a = 2\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn div [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (quot (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; XOR instruction\r\n;;\r\n;; Syntax:\r\n;; xor a b\r\n;;\r\n;; Bit xor `a` and `b` (number or register) and stores the result in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 10\r\n;;     mov :b 5\r\n;;     xor :a :b\r\n;; Will leave :a = 15\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn xor [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (bit-xor (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; AND instruction\r\n;;\r\n;; Syntax:\r\n;; and a b\r\n;;\r\n;; Bit-and `a` and `b` (number or register) and stores the result in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 1\r\n;;     mov :b 1\r\n;;     and :a :b\r\n;; Will leave :a = 1\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn bitand [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (bit-and (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; OR instruction\r\n;;\r\n;; Syntax:\r\n;; or a b\r\n;;\r\n;; Bit-or `a` and `b` (number or register) and stores the result in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 1\r\n;;     mov :b 0\r\n;;     or :a :b\r\n;; Will leave :a = 1\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn bitor [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (bit-and (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; cat instruction\r\n;;\r\n;; Syntax:\r\n;; cat a b\r\n;;\r\n;; Concatentates two strings `a` (registers) and `b` (registers or string literal), stores the result in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 'hello '\r\n;;     mov :b 'world'\r\n;;     cat :a :b\r\n;; Will leave :a 'hello world'\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn str-cat [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (str (get-value registers a) (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; inc instruction\r\n;;\r\n;; Syntax:\r\n;; inc a\r\n;;\r\n;; Increments the value in registers `a`, stores the incremented value in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 5\r\n;;     inc :a\r\n;; Will leave :a = 6\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn increment [{:keys [registers] :as memory} [a]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (inc (get-value registers a)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; dec instruction\r\n;;\r\n;; Syntax:\r\n;; dec a\r\n;;\r\n;; Decrements the value in registers `a`, stores the decremented value in `a`\r\n;; e.g.\r\n;; \r\n;;     mov :a 5\r\n;;     dec :a\r\n;; Will leave :a = 4\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn decrement [{:keys [registers] :as memory} [a]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (dec (get-value registers a)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; not instruction\r\n;;\r\n;; Syntax:\r\n;; not a\r\n;;\r\n;; Performs bit-not on 'a', stores the result in 'a'\r\n;; e.g.\r\n;; \r\n;;     mov :a 5\r\n;;     not :a\r\n;; Will leave :a = -6\r\n;;\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn bitnot [{:keys [registers] :as memory} [a]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (bit-not (get-value registers a)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; nop instruction\r\n;;\r\n;; Syntax:\r\n;; nop\r\n;;\r\n;; Does nothing. Label instructions are treated as nops.\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn nop [memory]\r\n  (update memory :eip inc))\r\n\r\n;;=======================================================================================================\r\n;; nop instruction\r\n;;\r\n;; Syntax:\r\n;; nop\r\n;;\r\n;; Does nothing.\r\n;; Increments eip to next instruction.\r\n;;=======================================================================================================\r\n(defn strlen [{:keys [registers] :as memory} [a b]]\r\n  (-> memory\r\n      (update-in [:registers] assoc a (count (get-value registers b)))\r\n      (update :eip inc)))\r\n\r\n;;=======================================================================================================\r\n;; jnz instruction\r\n;;\r\n;; Syntax:\r\n;; jnz a b\r\n;;\r\n;; Jumps `b` (number or register) instructions (positive or negative) if `a` (number or register) is not\r\n;; zero.\r\n;; If it is zero, then increments the eip.\r\n;;=======================================================================================================\r\n(defn jnz [{:keys [eip registers] :as memory} [a b]]\r\n  (let [jmp (if (zero? (get-value registers a)) 1 (get-value registers b))]\r\n    (assoc memory :eip (+ eip jmp))))\r\n\r\n;;=======================================================================================================\r\n;; jmp instruction\r\n;;\r\n;; Syntax:\r\n;; jmp a\r\n;;\r\n;; Moves the execution pointer to the label `a`.\r\n;; It finds the address for `a` by loking up `a` in the symbol tale.\r\n;;=======================================================================================================\r\n(defn jmp [{:keys [symbol-table] :as memory} [a]]\r\n  (assoc memory :eip (get symbol-table a)))\r\n\r\n;;=======================================================================================================\r\n;; cmp instruction\r\n;;\r\n;; Syntax:\r\n;; cmp a b (a and b can be values or registers.)\r\n;;\r\n;; Compares `a` and `b` and stores the result in the :cmp internal register.\r\n;; A comparison can be :eq (a = b)\r\n;;                     :gt (a > b)\r\n;;                     :lt (a < b)\r\n;; Increments the eip\r\n;;=======================================================================================================\r\n(defn cmp [{:keys [registers] :as memory} [a b]]\r\n  (let [av (get-value registers a)\r\n        bv (get-value registers b)]\r\n    (-> memory\r\n        (assoc-in [:internal-registers :cmp] (cond (= av bv) :eq\r\n                                                   (> av bv) :gt\r\n                                                   (< av bv) :lt))\r\n        (update :eip inc))))\r\n\r\n;;=======================================================================================================\r\n;; Handles jne, jg, jl, jle, jge, je\r\n;;\r\n;; jne - jumps to label if previous cmp call was not equal (greater-than or less-than)\r\n;; je  - jumps to labe if previous cmp call was equal\r\n;; jg  - jumps to label if previous cmp call was greater-than\r\n;; jge - jumps to label if previous cmp call was greater-than or equal-to\r\n;; jl  - jumps to label if previous cmp call was less-than\r\n;; jle - jumps to label if previous cmp call was less-than or equal-to\r\n;;\r\n;; Syntax (syntax is same for all the supported jumps):\r\n;; jne foo\r\n;; \r\n;; jumps to the label foo if the result of the previous cmp call fufills jmp predicate\r\n;;=======================================================================================================\r\n(defn cmp-jmp [{:keys [eip internal-registers symbol-table] :as memory} jump-type [a]]\r\n  (let [cmp              (:cmp internal-registers)\r\n        valid-predicates (cmp-jump-predicates jump-type)]\r\n    (prn cmp)\r\n    (prn valid-predicates)\r\n    (assoc memory :eip (if (valid-predicates cmp)\r\n                         (symbol-table (keyword a))\r\n                         (inc eip)))))\r\n\r\n\r\n(comment (cmp-jmp {:eip 3 :internal-registers {:cmp :lt} :symbol-table {:foo 5}} :jne [:foo]))\r\n\r\n;;=======================================================================================================\r\n;; call instruction\r\n;;\r\n;; Syntax:\r\n;; call foo\r\n;;\r\n;; Moves eip pointer to the label foo.\r\n;; Pushes the eip at the call site to the eip-stack as a ret target.\r\n;;=======================================================================================================\r\n(defn call [{:keys [eip symbol-table] :as memory} [a]]\r\n  (let [target (symbol-table (keyword a))]\r\n    (-> memory\r\n        (update :eip-stack conj eip)\r\n        (assoc :eip target))))\r\n\r\n;;=======================================================================================================\r\n;; ret instruction\r\n;;\r\n;; Syntax:\r\n;; ret\r\n;;\r\n;; Moves eip pointer to the top eip on the eip-stack\r\n;;=======================================================================================================\r\n(defn ret [{:keys [eip-stack] :as memory}]\r\n  (-> memory\r\n      (assoc :eip (inc (peek eip-stack)))\r\n      (update :eip-stack pop)))\r\n\r\n;;=======================================================================================================\r\n;; pop instruction\r\n;;\r\n;; Syntax:\r\n;; pop a\r\n;;\r\n;; Pops a value off the stack into register a.\r\n;; Increments the eip\r\n;;\r\n;; ERR: Will set :err field to \"Popped empty stack\" if stack is empty.\r\n;;=======================================================================================================\r\n(defn pop-stack [{:keys [stack] :as memory} [a]]\r\n  (if (empty? stack)\r\n    (-> memory\r\n        (update-in [:internal-registers] assoc :err \"Popped empty stack.\")\r\n        (update :eip inc))\r\n    (-> memory\r\n        (assoc-in [:registers a] (peek stack))\r\n        (update :stack (if (empty? stack) identity pop))\r\n        (assoc :last-edit-register a)\r\n        (update :eip inc))))\r\n\r\n;;=======================================================================================================\r\n;; push instruction\r\n;;\r\n;; Syntax:\r\n;; push a\r\n;;\r\n;; Pushes a (register or value) onto the stack.\r\n;; Increments the eip\r\n;;=======================================================================================================\r\n(defn push [{:keys [registers] :as memory} args]\r\n  (let [x (get-value registers (first args))]\r\n    (-> memory\r\n        (update :stack conj x)\r\n        (update :eip inc))))\r\n\r\n;;=======================================================================================================\r\n;; rep instruction\r\n;;\r\n;; Syntax:\r\n;; rep a\r\n;; rep\r\n;;\r\n;; If a value `a` is supplied (number or register) then rep sets a rep-counter and pushes it to the\r\n;; rp-stack, also pushes current eip to eip-stack (in this case it is an rp target)\r\n;; If no args are supplied, it only pushes the current eip to the eip-stack (in this case its a conditional\r\n;; rp target).\r\n;; `a` should be greater than zero. If it's passed zero, it will still run through the loop once.\r\n;;=======================================================================================================\r\n(defn rep [{:keys [eip registers] :as memory} args]\r\n  (if (seq args)\r\n    (-> memory\r\n        (update-in [:rep-counters-stack] conj (get-value registers (first args)))\r\n        (update-in [:eip-stack] conj eip)\r\n        (update :eip inc))\r\n    (-> memory\r\n        (update-in [:eip-stack] conj eip)\r\n        (update :eip inc))))\r\n\r\n;;=======================================================================================================\r\n;; rp instruction\r\n;;\r\n;; Syntax:\r\n;; rp\r\n;;\r\n;; Decrements the top item on the RP stack. If it would be zero after decrementing then it increments the\r\n;; eip. Otherwise it sets eip to the top value of the eip-stack.\r\n;;=======================================================================================================\r\n(defn rp [{:keys [eip-stack] :as memory}]\r\n  (let [counter (peek (memory :rep-counters-stack))]\r\n    (if (<= counter 1) ; decrementing would reduce it to zero, so increment eip and pop the rp-stack.\r\n      (-> memory\r\n          (update :rep-counters-stack pop)\r\n          (update :eip-stack pop)\r\n          (update :eip inc))\r\n      (-> memory ; otherwise decrement the top item on the rp-stack and set eip to top value on eip-stack.\r\n          (update :rep-counters-stack pop)\r\n          (update :rep-counters-stack conj (dec counter))\r\n          (assoc :eip (inc (peek eip-stack)))))))\r\n\r\n(defn get-conditional-repeat-function [f]\r\n  (condp = f\r\n    :rz (fn [x] (not (zero? x)))\r\n    :rnz zero?\r\n    :rlez (fn [x] (> x 0))\r\n    :rlz (fn [x] (>= x 0))\r\n    :rgz (fn [x] (<= x 0))\r\n    :rgez (fn [x] (< x 0))))\r\n\r\n;;=======================================================================================================\r\n;; r*z conditional repeats\r\n;;\r\n;; Syntax:\r\n;; rz a      Repeats until `a` is zero.\r\n;; rnz a     Repeats until `a` is not zero.\r\n;; rlez a    Repeat until `a` is less than or equal to zero.\r\n;; rgez a    Repeat until `a` is greater than or equal to zero.\r\n;; rgz a     Repeat until `a` is greater than zero.\r\n;; rlz a     Repeat until `a` is less than zero.\r\n;;=======================================================================================================\r\n(defn conditional-repeat [{:keys [eip-stack registers] :as memory} instruction [a]]\r\n  (let [condition (get-conditional-repeat-function instruction)]\r\n    (if (condition (get-value registers a))\r\n      (-> memory\r\n          (assoc :eip (inc (peek eip-stack))))\r\n      (-> memory\r\n          (update :eip inc)\r\n          (update :eip-stack pop)))))\r\n\r\n;;=======================================================================================================\r\n;; The interpreter.\r\n;;=======================================================================================================\r\n(defn interpret [instructions {:keys [eip] :as memory}]\r\n  (let [[instruction & args] (nth instructions eip)\r\n        memory (cond (= :mov instruction)\r\n                     (mov memory args)\r\n\r\n                     (= :add instruction)\r\n                     (add memory args)\r\n\r\n                     (= :sub instruction)\r\n                     (sub memory args)\r\n\r\n                     (= :mul instruction)\r\n                     (mul memory args)\r\n\r\n                     (= :div instruction)\r\n                     (div memory args)\r\n\r\n                     (= :xor instruction)\r\n                     (xor memory args)\r\n\r\n                     (= :and instruction)\r\n                     (bitand memory args)\r\n\r\n                     (= :or instruction)\r\n                     (bitor memory args)\r\n\r\n                     (= :cat instruction)\r\n                     (str-cat memory args)\r\n\r\n                     (= :inc instruction)\r\n                     (increment memory args)\r\n\r\n                     (= :dec instruction)\r\n                     (decrement memory args)\r\n\r\n                     (= :not instruction)\r\n                     (bitnot memory args)\r\n\r\n                     (= :len instruction)\r\n                     (strlen memory args)\r\n\r\n                     (= :nop instruction)\r\n                     (nop memory)\r\n\r\n                     (= :prn instruction)\r\n                     (prnout memory args)\r\n\r\n                     (= :jnz instruction)\r\n                     (jnz memory args)\r\n\r\n                     (= :label instruction)\r\n                     (nop memory)\r\n\r\n                     (= :jmp instruction)\r\n                     (jmp memory args)\r\n\r\n                     (= :cmp instruction)\r\n                     (cmp memory args)\r\n\r\n                     (#{:jne :jg :je :jl :jle :jge} instruction)\r\n                     (cmp-jmp memory instruction args)\r\n\r\n                     (= :call instruction)\r\n                     (call memory args)\r\n\r\n                     (= :ret instruction)\r\n                     (ret memory)\r\n\r\n                     (= :push instruction)\r\n                     (push memory args)\r\n\r\n                     (= :pop instruction)\r\n                     (pop-stack memory args)\r\n\r\n                     (= :rep instruction)\r\n                     (rep memory args)\r\n\r\n                     (= :rp instruction)\r\n                     (rp memory)\r\n\r\n                     (#{:rnz :rz :rgz :rlz :rgez :rlez} instruction)\r\n                     (conditional-repeat memory instruction args)\r\n\r\n                     :else\r\n                     memory)]\r\n    {:memory memory\r\n     :finished? (or (= :end instruction) (> (memory :eip) (count instructions)))}))\r\n\r\n"]}