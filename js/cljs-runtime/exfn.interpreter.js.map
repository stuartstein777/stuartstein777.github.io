{"version":3,"sources":["exfn/interpreter.cljs"],"mappings":"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","names":["exfn.interpreter/get-parity","n","cljs.core/even?","p1__47759#","cljs.core.filter","cljs.core._EQ_","cljs.core/count","exfn.interpreter/get-value","registers","x","cljs.core/Keyword","cljs.core.get","exfn.interpreter/cmp-jump-predicates","jump-instruction","pred__47760","expr__47761","js/Error","cljs.core/=","exfn.interpreter/build-symbol-table","asm","cljs.core.reduce","p__47763","vec__47764","cljs.core.nth","a","i","ix","cljs.core/first","cljs.core.assoc","cljs.core/second","cljs.core.map","cljs.core/vector","cljs.core.range","exfn.interpreter/append-output","existing","new","and__4115__auto__","cljs.core/not","p__47767","p__47768","map__47769","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","vec__47770","exfn.interpreter/mov","memory","b","cljs.core.update","cljs.core/assoc","p__47774","map__47775","exfn.interpreter/prnout","output","args","exfn.interpreter/get-math-fun","f","pred__47777","expr__47778","cljs.core/+","cljs.core/-","cljs.core/quot","cljs.core/*","cljs.core/bit-xor","cljs.core/bit-and","cljs.core/bit-or","exfn.interpreter/add-error","err-no","err-msg","cljs.core.update_in","p__47780","p__47781","map__47782","vec__47783","exfn.interpreter/math-func","instruction","av","bv","result","fexpr__47787","p__47788","p__47789","map__47790","vec__47791","exfn.interpreter/str-cat","p__47795","p__47796","map__47797","vec__47798","exfn.interpreter/increment","p__47802","p__47803","map__47804","vec__47805","exfn.interpreter/decrement","p__47809","p__47810","map__47811","vec__47812","exfn.interpreter/bitnot","p__47816","p__47817","map__47818","vec__47819","exfn.interpreter/strlen","p__47823","p__47824","map__47825","vec__47826","exfn.interpreter/jnz","eip","jmp","p__47830","p__47831","map__47832","vec__47833","exfn.interpreter/jmp","symbol-table","p__47837","p__47838","map__47839","vec__47840","exfn.interpreter/cmp","cljs.core/assoc-in","p__47844","p__47845","map__47846","vec__47847","exfn.interpreter/cmp-jmp","internal-registers","jump-type","cmp","valid-predicates","cljs.core.prn","G__47851","cljs.core.keyword","p__47852","p__47853","map__47854","vec__47855","exfn.interpreter/call","target","G__47859","cljs.core/conj","p__47860","map__47861","exfn.interpreter/ret","eip-stack","cljs.core/peek","cljs.core/pop","p__47863","p__47864","map__47865","vec__47866","exfn.interpreter/pop-stack","stack","cljs.core/empty?","cljs.core/identity","p__47870","map__47871","exfn.interpreter/push","p__47873","map__47874","exfn.interpreter/rep","cljs.core/seq","p__47876","map__47877","exfn.interpreter/rp","counter","cljs.core/inc","exfn.interpreter/get-conditional-repeat-function","pred__47879","expr__47880","cljs.core/zero?","p__47882","p__47883","map__47884","vec__47885","exfn.interpreter/conditional-repeat","condition","G__47889","p__47890","map__47891","exfn.interpreter/interpret","instructions","vec__47893","seq__47894","first__47895","cljs.core/next","fexpr__47896","fexpr__47897","fexpr__47898","fexpr__47899","terminated?"],"sourcesContent":["(ns exfn.interpreter)\n\n;;=======================================================================================================\n;; Returns 1 if n has an even number of 1s in its binary representation, otherwise 0.\n;;=======================================================================================================\n(defn get-parity [n]\n  (if (even? (-> (filter #(= \"1\" %) (.toString n 2)) count)) 1 0))\n\n;;=======================================================================================================\n;; if x is a register, returns the value from the registers.\n;; Otherwise return x (as it's a value not a register).\n;;=======================================================================================================\n(defn get-value [registers x]\n  (if (keyword? x)\n    (get registers x)\n    x))\n\n;;=======================================================================================================\n;; Return the predicate for cmp jumps that we want the jump check to satisfy.\n;;\n;; If jump is jge (jump if greater than or equal), then valid predicates for cmp are :eq (equal to) or :gt (greater than)\n;; If jump is jge (jump if greater than), then valid predicates for cmp are :gt (greater than)\n;; If jump is jne (jump if not equal), then valid predicates for cmp are :gt (greater than) or :lt (less than)\n;; If jump is je (jump if equal), then valid predicates for cmp are :eq (equal to)\n;; If jump is jle (jump if less than or equal), then valid predicates for cmp are :eq (equal to) or :lt (less than)\n;; If jump is jl (jump if less than), then valid predicates for cmp are :lt (less than)\n;;=======================================================================================================\n(defn cmp-jump-predicates [jump-instruction]\n  (condp = jump-instruction\n    :jge #{:eq :gt}\n    :jg  #{:gt}\n    :jne #{:lt :gt}\n    :je  #{:eq}\n    :jle #{:eq :lt}\n    :jl  #{:lt}))\n\n;;=======================================================================================================\n;; Builds the symbol table for jump targets\n;; A jump target is a label of form foo:\n;;=======================================================================================================\n(defn build-symbol-table [asm]\n  (reduce (fn [a [i ix]]\n            (if (= (first ix) :label)\n              (assoc a (second ix) i)\n              a))\n          {}\n          (map vector (range) asm)))\n\n;;=======================================================================================================\n;; Update the existing output with the new line of output.\n;;=======================================================================================================\n(defn append-output [existing new]\n  (cond (and existing new)\n        (str existing \"\\n\" new)\n\n        (and existing (not new))\n        existing\n\n        (= \"\" existing)\n        new))\n\n;;=======================================================================================================\n;; MOV instruction\n;;\n;; Syntax:\n;; mov a b\n;;\n;; Moves the contents of `b` (value or register) into register `a`\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn mov [{:keys [registers] :as memory} [a b]]\n  (-> memory\n      (update :registers assoc a (get-value registers b))))\n\n;;=======================================================================================================\n;; PRN instruction\n;;\n;; Syntax:\n;; prn a\n;;\n;; Appends the contents of a (string / number / register) to output\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn prnout [{:keys [output registers] :as memory} args]\n  (-> memory\n      (assoc :output (append-output output (get-value registers (first args))))))\n\n;;=======================================================================================================\n;; Gets the function to apply for the given instruction f.\n;;=======================================================================================================\n(defn get-math-fun [f]\n  (condp = f\n    :add +\n    :sub -\n    :div quot\n    :mul *\n    :xor bit-xor\n    :and bit-and\n    :or bit-or))\n\n(defn add-error [memory err-no err-msg]\n  (-> memory\n      (update-in [:internal-registers] assoc :err err-no)\n      (update-in [:internal-registers] assoc :errmsg err-msg)))\n\n;;=======================================================================================================\n;; math instruction, covers add, sub, div, mul, xor, and, or\n;;\n;; Syntax:\n;; instruction a b\n;;\n;; Performs the math operation for instruction passing `a` and `b` as args. Stores the result in `a`.\n;; Sets the parity flag if result in `a` has even number of bits in its binary representation.\n;;=======================================================================================================\n(defn math-func [instruction {:keys [registers] :as memory} [a b]]\n  (let [av (get-value registers a)\n        bv (get-value registers b)]\n    (if (or (not (number? av)) (not (number? bv)))\n      (add-error memory 1 (str \"Math operation \" instruction \" performed on non number arguments.\" a \" and \" b))\n      (let [result ((get-math-fun instruction) av bv)]\n        (-> memory\n            (update-in [:registers] assoc a result)\n            (update-in [:internal-registers] assoc :par (get-parity result)))))))\n\n;;=======================================================================================================\n;; cat instruction\n;;\n;; Syntax:\n;; cat a b\n;;\n;; Concatentates two strings `a` (registers) and `b` (registers or string literal), stores the result in `a`\n;; e.g.\n;; \n;;     mov :a 'hello '\n;;     mov :b 'world'\n;;     cat :a :b\n;; Will leave :a 'hello world'\n;;\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn str-cat [{:keys [registers] :as memory} [a b]]\n  (-> memory\n      (update-in [:registers] assoc a (str (get-value registers a) (get-value registers b)))))\n\n;;=======================================================================================================\n;; inc instruction\n;;\n;; Syntax:\n;; inc a\n;;\n;; Increments the value in registers `a`, stores the incremented value in `a`\n;; e.g.\n;; \n;;     mov :a 5\n;;     inc :a\n;; Will leave :a = 6\n;;\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn increment [{:keys [registers] :as memory} [a]]\n  (let [result (inc (get-value registers a))]\n    (-> memory\n        (update-in [:registers] assoc a result)\n        (update-in [:internal-registers] assoc :par (get-parity result)))))\n\n;;=======================================================================================================\n;; dec instruction\n;;\n;; Syntax:\n;; dec a\n;;\n;; Decrements the value in registers `a`, stores the decremented value in `a`\n;; e.g.\n;; \n;;     mov :a 5\n;;     dec :a\n;; Will leave :a = 4\n;;\n;; Increments eip to next instruction.\n;;=======================================================================================================\n(defn decrement [{:keys [registers] :as memory} [a]]\n  (let [result (dec (get-value registers a))]\n    (-> memory\n        (update-in [:registers] assoc a result)\n        (update-in [:internal-registers] assoc :par (get-parity result)))))\n\n;;=======================================================================================================\n;; not instruction\n;;\n;; Syntax:\n;; not a\n;;\n;; Performs bit-not on 'a', stores the result in 'a'\n;; e.g.\n;; \n;;     mov :a 5\n;;     not :a\n;; Will leave :a = -6\n;;\n;;=======================================================================================================\n(defn bitnot [{:keys [registers] :as memory} [a]]\n  (if (number? a)\n    (let [result (bit-not (get-value registers a))]\n      (-> memory\n          (update-in [:registers] assoc a result)\n          (update-in [:internal-registers] assoc :par (get-parity result))\n          (assoc :last-edit-register a)))\n    (-> memory\n        (update-in [:internal-registers] assoc :err 1))))\n\n;;=======================================================================================================\n;; strlen\n;;\n;; Syntax:\n;; strlen a b\n;;\n;; Stores the length of string `b` in `a`\n;;=======================================================================================================\n(defn strlen [{:keys [registers] :as memory} [a b]]\n  (-> memory\n      (update-in [:registers] assoc a (count (get-value registers b)))))\n\n;;=======================================================================================================\n;; jnz instruction\n;;\n;; Syntax:\n;; jnz a b\n;;\n;; Jumps `b` (number or register) instructions (positive or negative) if `a` (number or register) is not\n;; zero.\n;; If it is zero, then increments the eip.\n;;=======================================================================================================\n(defn jnz [{:keys [eip registers] :as memory} [a]]\n  (let [a (get-value registers a)\n        jmp (if (zero? a) 1 a)]\n    (assoc memory :eip (+ eip jmp))))\n\n;;=======================================================================================================\n;; jmp instruction\n;;\n;; Syntax:\n;; jmp a\n;;\n;; Moves the execution pointer to the label `a`.\n;; It finds the address for `a` by loking up `a` in the symbol tale.\n;;=======================================================================================================\n(defn jmp [{:keys [symbol-table] :as memory} [a]]\n  (assoc memory :eip (get symbol-table a)))\n\n;;=======================================================================================================\n;; cmp instruction\n;;\n;; Syntax:\n;; cmp a b (a and b can be values or registers.)\n;;\n;; Compares `a` and `b` and stores the result in the :cmp internal register.\n;; A comparison can be :eq (a = b)\n;;                     :gt (a > b)\n;;                     :lt (a < b)\n;; Increments the eip\n;;=======================================================================================================\n(defn cmp [{:keys [registers] :as memory} [a b]]\n  (let [av (get-value registers a)\n        bv (get-value registers b)]\n    (-> memory\n        (assoc-in [:internal-registers :cmp] (cond (= av bv) :eq\n                                                   (> av bv) :gt\n                                                   (< av bv) :lt)))))\n\n;;=======================================================================================================\n;; Handles jne, jg, jl, jle, jge, je\n;;\n;; jne - jumps to label if previous cmp call was not equal (greater-than or less-than)\n;; je  - jumps to labe if previous cmp call was equal\n;; jg  - jumps to label if previous cmp call was greater-than\n;; jge - jumps to label if previous cmp call was greater-than or equal-to\n;; jl  - jumps to label if previous cmp call was less-than\n;; jle - jumps to label if previous cmp call was less-than or equal-to\n;;\n;; Syntax (syntax is same for all the supported jumps):\n;; jne foo\n;; \n;; jumps to the label foo if the result of the previous cmp call fufills jmp predicate\n;;=======================================================================================================\n(defn cmp-jmp [{:keys [eip internal-registers symbol-table] :as memory} jump-type [a]]\n  (let [cmp              (:cmp internal-registers)\n        valid-predicates (cmp-jump-predicates jump-type)]\n    (prn cmp)\n    (prn valid-predicates)\n    (assoc memory :eip (if (valid-predicates cmp)\n                         (symbol-table (keyword a))\n                         (inc eip)))))\n\n\n(comment (cmp-jmp {:eip 3 :internal-registers {:cmp :lt} :symbol-table {:foo 5}} :jne [:foo]))\n\n;;=======================================================================================================\n;; call instruction\n;;\n;; Syntax:\n;; call foo\n;;\n;; Moves eip pointer to the label foo.\n;; Pushes the eip at the call site to the eip-stack as a ret target.\n;;=======================================================================================================\n(defn call [{:keys [eip symbol-table] :as memory} [a]]\n  (let [target (symbol-table (keyword a))]\n    (-> memory\n        (update :eip-stack conj eip)\n        (assoc :eip target))))\n\n;;=======================================================================================================\n;; ret instruction\n;;\n;; Syntax:\n;; ret\n;;\n;; Moves eip pointer to the top eip on the eip-stack\n;;=======================================================================================================\n(defn ret [{:keys [eip-stack] :as memory}]\n  (-> memory\n      (assoc :eip (inc (peek eip-stack)))\n      (update :eip-stack pop)))\n\n;;=======================================================================================================\n;; pop instruction\n;;\n;; Syntax:\n;; pop a\n;;\n;; Pops a value off the stack into register a.\n;; Increments the eip\n;;\n;; ERR: Will set :err field to \"Popped empty stack\" if stack is empty.\n;;=======================================================================================================\n(defn pop-stack [{:keys [stack] :as memory} [a]]\n  (if (empty? stack)\n    (-> memory\n        (update-in [:internal-registers] assoc :err \"Popped empty stack.\"))\n    (-> memory\n        (assoc-in [:registers a] (peek stack))\n        (update :stack (if (empty? stack) identity pop))\n        (assoc :last-edit-register a))))\n\n;;=======================================================================================================\n;; push instruction\n;;\n;; Syntax:\n;; push a\n;;\n;; Pushes a (register or value) onto the stack.\n;;=======================================================================================================\n(defn push [{:keys [registers] :as memory} args]\n  (let [x (get-value registers (first args))]\n    (-> memory\n        (update :stack conj x))))\n\n;;=======================================================================================================\n;; rep instruction\n;;\n;; Syntax:\n;; rep a\n;; rep\n;;\n;; If a value `a` is supplied (number or register) then rep sets a rep-counter and pushes it to the\n;; rp-stack, also pushes current eip to eip-stack (in this case it is an rp target)\n;; If no args are supplied, it only pushes the current eip to the eip-stack (in this case its a conditional\n;; rp target).\n;; `a` should be greater than zero. If it's passed zero, it will still run through the loop once.\n;;=======================================================================================================\n(defn rep [{:keys [eip registers] :as memory} args]\n  (if (seq args)\n    (-> memory\n        (update-in [:rep-counters-stack] conj (get-value registers (first args)))\n        (update-in [:eip-stack] conj eip))\n    (-> memory\n        (update-in [:eip-stack] conj eip))))\n\n;;=======================================================================================================\n;; rp instruction\n;;\n;; Syntax:\n;; rp\n;;\n;; Decrements the top item on the RP stack. If it would be zero after decrementing then it increments the\n;; eip. Otherwise it sets eip to the top value of the eip-stack.\n;;=======================================================================================================\n(defn rp [{:keys [eip-stack] :as memory}]\n  (let [counter (peek (memory :rep-counters-stack))]\n    (if (<= counter 1) ; decrementing would reduce it to zero, so increment eip and pop the rp-stack.\n      (-> memory\n          (update :rep-counters-stack pop)\n          (update :eip-stack pop)\n          (update :eip inc))\n      (-> memory ; otherwise decrement the top item on the rp-stack and set eip to top value on eip-stack.\n          (update :rep-counters-stack pop)\n          (update :rep-counters-stack conj (dec counter))\n          (assoc :eip (inc (peek eip-stack)))))))\n\n(defn get-conditional-repeat-function [f]\n  (condp = f\n    :rz (fn [x] (not (zero? x)))\n    :rnz zero?\n    :rlez (fn [x] (> x 0))\n    :rlz (fn [x] (>= x 0))\n    :rgz (fn [x] (<= x 0))\n    :rgez (fn [x] (< x 0))))\n\n;;=======================================================================================================\n;; r*z conditional repeats\n;;\n;; Syntax:\n;; rz a      Repeats until `a` is zero.\n;; rnz a     Repeats until `a` is not zero.\n;; rlez a    Repeat until `a` is less than or equal to zero.\n;; rgez a    Repeat until `a` is greater than or equal to zero.\n;; rgz a     Repeat until `a` is greater than zero.\n;; rlz a     Repeat until `a` is less than zero.\n;;=======================================================================================================\n(defn conditional-repeat [{:keys [eip-stack registers] :as memory} instruction [a]]\n  (let [condition (get-conditional-repeat-function instruction)]\n    (if (condition (get-value registers a))\n      (-> memory\n          (assoc :eip (inc (peek eip-stack))))\n      (-> memory\n          (update :eip inc)\n          (update :eip-stack pop)))))\n\n;;=======================================================================================================\n;; The interpreter.\n;;=======================================================================================================\n(defn interpret [instructions {:keys [eip] :as memory}]\n  (let [[instruction & args] (nth instructions eip)\n        memory (cond (= :mov instruction)\n                     (-> (mov memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (#{:add :sub :mul :div :xor :and :or} instruction)\n                     (-> (math-func instruction memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :cat instruction)\n                     (-> (str-cat memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :inc instruction)\n                     (-> (increment memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :dec instruction)\n                     (-> (decrement memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (= :not instruction)\n                     (-> (bitnot memory args)\n                         (update :eip inc))\n\n                     (= :len instruction)\n                     (-> (strlen memory args)\n                         (assoc :last-edit-register (first args))\n                         (update :eip inc))\n\n                     (#{:nop :label} instruction)\n                     (update memory :eip inc)\n\n                     (= :prn instruction)\n                     (-> (prnout memory args)\n                         (update :eip inc))\n\n                     (= :jnz instruction)\n                     (jnz memory args)\n\n                     (= :jmp instruction)\n                     (jmp memory args)\n\n                     (= :cmp instruction)\n                     (-> memory\n                         (cmp args)\n                         (update :eip inc))\n\n                     (#{:jne :jg :je :jl :jle :jge} instruction)\n                     (cmp-jmp memory instruction args)\n\n                     (= :call instruction)\n                     (call memory args)\n\n                     (= :ret instruction)\n                     (ret memory)\n\n                     (= :push instruction)\n                     (-> memory\n                         (push args)\n                         (update :eip inc))\n\n                     (= :pop instruction)\n                     (-> memory\n                         (pop-stack args)\n                         (update :eip inc))\n\n                     (= :rep instruction)\n                     (-> memory\n                         (rep args)\n                         (update :eip inc))\n\n                     (= :rp instruction)\n                     (rp memory)\n\n                     (#{:rnz :rz :rgz :rlz :rgez :rlez} instruction)\n                     (conditional-repeat memory instruction args)\n\n                     :else\n                     memory)\n        terminated? (> (memory :eip) (dec (count instructions)))]\n      {:memory (if terminated? \n                 (assoc memory :output (append-output (memory :output) \"*** Program terminated: EIP past last instruction. ***\"))\n                 memory)\n       :terminated? terminated?\n       :finished? (= :end instruction)}))\n"]}