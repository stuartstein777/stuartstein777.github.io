{"version":3,"sources":["exfn/interpreter.cljs"],"mappings":"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","names":["exfn.interpreter/get-value","registers","x","cljs.core/Keyword","cljs.core.get","exfn.interpreter/mov","y","cljs.core.assoc","exfn.interpreter/unary-op","op","cljs.core.update","exfn.interpreter/binary-op","G__49718","G__49719","exfn.interpreter/cmp-jump-predicates","jump-instruction","cljs.core._EQ_","exfn.interpreter/get-binary-operations","instruction","cljs.core/+","cljs.core/-","cljs.core/*","cljs.core/quot","cljs.core/bit-xor","cljs.core/bit-or","cljs.core/bit-and","exfn.interpreter/get-unary-operation","cljs.core/inc","cljs.core/dec","exfn.interpreter/jnz","exfn.interpreter/cmp","x-val","y-val","exfn.interpreter/cmp-jmp","internal-registers","symbol-table","eip","valid-comps","lbl","G__49720","exfn.interpreter/call","label","var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","exfn.interpreter/set-message","seq49721","G__49722","cljs.core/first","cljs.core/next","self__4723__auto__","args","cljs.core/assoc-in","cljs.core.reduce","s","a","exfn.interpreter/return-value","return-registers?","res","ret-value","cljs.core/re-matches","js/Number","cljs.core.dissoc","exfn.interpreter/process-jump","eip-stack","vec__49723","cljs.core.nth","fexpr__49726","pred","cljs.core/empty?","cljs.core/peek","p__49728","map__49729","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","exfn.interpreter/process-instruction","stack","memory","vec__49731","fexpr__49734","fexpr__49735","vec__49736","vec__49739","cljs.core.update_in","cljs.core/assoc","cljs.core/identity","cljs.core/pop","p1__49727#","cljs.core.conj","cljs.core.partial","exfn.interpreter/build-symbol-table","asm","p__49742","vec__49743","i","ix","cljs.core/second","cljs.core.map","cljs.core/vector","cljs.core.range","p__49746","map__49747","exfn.interpreter/interpret","instructions","vec__49749","seq__49750","cljs.core/seq","first__49751","new-eip","fexpr__49752","fexpr__49753","cljs.core.prn","cljs.core/count"],"sourcesContent":["(ns exfn.interpreter)\n\n;;=======================================================================================================\n;; if x is a register, returns the value from the registers.\n;; Otherwise return x (as it's a value not a register).\n;;=======================================================================================================\n(defn get-value [registers x]\n  (if (keyword? x)\n    (get registers x)\n    x))\n\n;;=======================================================================================================\n;; Handle the mov instruction.\n;;=======================================================================================================\n(defn mov [registers x y]\n  (assoc registers x (get-value registers y)))\n\n;;=======================================================================================================\n;; Handle unary operations\n;;=======================================================================================================\n(defn unary-op [registers op x]\n  (update registers x op))\n\n;;=======================================================================================================\n;; Handle binary operations\n;;=======================================================================================================\n(defn binary-op [registers op x y]\n  (assoc registers x (op (get registers x) (get-value registers y))))\n\n;;=======================================================================================================\n;; Return the predicate for cmp jumps that we want the jump check to satisfy.\n;;=======================================================================================================\n(defn cmp-jump-predicates [jump-instruction]\n  #_(js/console.log \"jump-instruction\" jump-instruction)\n  (cond (= :jge jump-instruction) #{:eq :gt}\n        (= :jg  jump-instruction) #{:gt}\n        (= :jne jump-instruction) #{:lt :gt}\n        (= :je  jump-instruction) #{:eq}\n        (= :jle jump-instruction) #{:eq :lt}\n        (= :jl  jump-instruction) #{:lt}))\n\n;;=======================================================================================================\n;; Return the appropriate binary operation for the given binary instruction.\n;;=======================================================================================================\n(defn get-binary-operations [instruction]\n  (cond (= :add instruction) +\n        (= :sub instruction) -\n        (= :mul instruction) *\n        (= :div instruction) quot\n        (= :xor instruction) bit-xor\n        (= :or  instruction)  bit-or\n        (= :and instruction) bit-and))\n\n;;=======================================================================================================\n;; Return the appropriate unary operation for the given unary instruction.\n;;=======================================================================================================\n(defn get-unary-operation [instruction]\n  (cond (= :inc instruction) inc\n        (= :dec instruction) dec))\n\n;;=======================================================================================================\n;; jump forward or backwards y steps if x is not zero.\n;; x and y can both be registers so we get their value via (get-value).\n;;=======================================================================================================\n(defn jnz [registers x y]\n  (if (zero? (get-value registers x))\n    1\n    (get-value registers y)))\n\n;;=======================================================================================================\n;; compare x and y and store if x > y, x = y or x < y\n;; the result is stored in internal-registers :cmp register.\n;;=======================================================================================================\n(defn cmp [registers x y]\n  (let [x-val (if (keyword? x) (get registers x) x)\n        y-val (if (keyword? y) (get registers y) y)]\n    (cond (= x-val y-val) :eq\n          (> x-val y-val) :gt\n          (< x-val y-val) :lt)))\n\n;;=======================================================================================================\n;; After a cmp either the comparison will be in one of three states, :eq, :gt, :lt\n;;\n;; Therefore, to check if we need to jump or not, we simple have to pass in a set of allowed states.\n;; e.g,\n;; jge :: we would pass in #{:eq :gt}, then we can check if the cmp register is either :eq or :gt.\n;;\n;; If it is in the set then we can return the location for the label (lbl) in the symbol table.\n;; Otherwise we just return the eip incremented so we advance to the next instruction.\n;;=======================================================================================================\n(defn cmp-jmp [internal-registers symbol-table eip valid-comps lbl]\n  (if (nil? (valid-comps (:cmp internal-registers)))\n    (inc eip)\n    (lbl symbol-table)))\n\n;;=======================================================================================================\n;; Handle call instructions.\n;; We return the eip we want to jump to from the symbol table for the given label.\n;;=======================================================================================================\n(defn call [symbol-table label]\n  (label symbol-table))\n\n;;=======================================================================================================\n;; Builds a string for the program return value from the arguments to the set: instruction.\n;;=======================================================================================================\n(defn set-message [registers & args]\n  (assoc-in registers [:internal-registers :return-code] (reduce (fn [s a] (str s (get-value registers a))) args)))\n\n;;=======================================================================================================\n;; Gets the return value for the program. If its a number, it will parse it to an Integer.\n;; Otherwise just return it as a string.\n;; If return-registers? is set then return a vector of the return value and the registers.\n;;=======================================================================================================\n(defn return-value [registers return-registers?]\n  (let [res (:return-code (:internal-registers registers))\n        ret-value (cond (nil? res) 0\n                        (re-matches #\"^[\\+\\-]?\\d*\\.?[Ee]?[\\+\\-]?\\d*$\" res) (js/Number res)\n                        :else res)]\n    (if return-registers?\n      [ret-value (dissoc registers :internal-registers)]\n      ret-value)))\n\n;;=======================================================================================================\n;; Process the jump instructions and return the new eip.\n;;=======================================================================================================\n(defn process-jump [eip instruction registers internal-registers symbol-table eip-stack args]\n  #_(prn \"JMP\" registers)\n  ;; if we are jumping to a label, just return the location of the label in the symbol-table\n  (cond (= :jmp instruction)\n        (inc (get symbol-table (first args)))\n\n        (= :jnz instruction)\n        (let [[x y] args]\n          (+ eip (jnz registers x y)))\n\n        ;; check if its a cmp jump.\n        (#{:jne :je :jge :jg :jle :jl} instruction)\n        (let [pred (cmp-jump-predicates instruction)\n              x    (first args)]\n          (cmp-jmp internal-registers symbol-table eip pred x))\n\n        (= :call instruction)\n        (call symbol-table (first args))\n\n        (= :ret instruction)\n        (if (empty? eip-stack)\n          -1\n          (inc (peek eip-stack)))\n\n        :else\n        (inc eip)))\n\n;;=======================================================================================================\n;; Process regular instructions and return the new registers.\n;;=======================================================================================================\n(defn process-instruction [instruction {:keys [registers stack] :as memory} args]\n  #_#_(prn \"args::\" args)\n  (prn \"memory::\" registers stack)\n  (cond (= :mov instruction)\n        (let [[x y] args]\n          (-> memory\n              (assoc :registers (mov registers x y))\n              (assoc :last-edit-register x)))\n\n        (#{:inc :dec} instruction)\n        (-> memory\n            (assoc :registers (unary-op registers (get-unary-operation instruction) (first args)))\n            (assoc :last-edit-register (first args)))\n\n        (#{:mul :add :sub :div :xor :and :or} instruction)\n        (let [[x y] args]\n          (-> memory\n              (assoc :registers (binary-op registers (get-binary-operations instruction) x y))\n              (assoc :last-edit-register x)))\n\n        (= :cmp instruction)\n        (let [[x y] args]\n          (assoc-in memory [:internal-registers :cmp] (cmp registers x y)))\n\n        (= :pop instruction)\n        (if (empty? stack)\n          (update-in memory [:internal-registers] assoc :err \"Popped empty stack.\")\n          (-> memory\n              (assoc :registers (mov registers (first args) (peek stack)))\n              (update :stack (if (empty? stack) identity pop))\n              (assoc :last-edit-register (first args))))\n\n        (= :push instruction)\n        (let [x (get-value registers (first args))]\n          (update memory :stack #(conj % x)))\n\n        (= :msg instruction)\n        (assoc memory :registers (apply (partial set-message registers) args))))\n\n(defn build-symbol-table [asm]\n  (reduce (fn [a [i ix]]\n        (if (= (first ix) :label)\n            (assoc a (second ix) i)\n            a))\n          {}\n          (map vector (range) asm)))\n\n;;=======================================================================================================\n;; The interpreter.\n;;=======================================================================================================\n(defn interpret [instructions {:keys [eip registers internal-registers symbol-table] :as memory}]\n  #_(js/console.log memory)\n  (let [[instruction & args] (nth instructions eip)]\n    (let [new-eip   (if (#{:jmp :jnz :jne :je :jgl :jg :jle :jl :jge :ret :call} instruction)\n                      (process-jump eip instruction registers internal-registers symbol-table (:eip-stack memory) args)\n                      (inc eip))\n\n          memory (if (#{:mov :mul :add :sub :dec :xor :and :or :div :inc :msg :cmp :push :pop} instruction)\n                   (process-instruction instruction memory args)\n                   memory)\n\n          eip-stack (cond (= :ret instruction) (pop (:eip-stack memory))\n                          (= :call instruction) (conj (:eip-stack memory) eip)\n                          :else (:eip-stack memory))]\n      (prn (:last-edit-register memory))\n      [(-> memory\n           (assoc :eip new-eip)\n           (assoc :eip-stack eip-stack))\n       (or (= (nth instructions new-eip) [:end]) (> new-eip (count instructions)))])))"]}