{"version":3,"sources":["exfn/helpers.cljs"],"mappings":";AAGA,AAAA,AAAMA,AAAyBC;AAA/B,AACE,AAAA,AAAW,AAACC,AAAO,AAAAC,AAAoCS;AAApC,AAAA,AAAAR,AAAAD;AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAE,AAAAC,AAAAH,AAAAA;AAAAA,AAA+BO;AAA/B,AAAAH,AAAAJ,AAAA,AAAaK;AAAb,AAAAD,AAAAJ,AAAA,AAAiBM;AAAjB,AACE,AAAI,AAAI,AAAA,AAACG,AAAKD,AAAG,AAAA,AAACE,AAA4BF;AAC5C,AAAA,AAACG,AAAMJ,AAAc,AAAA,AAAKD;;AACtBC,AACA,AAAA,AAACI,AAAgB,AAAA,AAAKL,AAASD,AAC/B,AAAA,AAACO,AAAYC;;AAL7B,AAAA,AAAA,AAAA,AAAA,AAOa,AAAA,AAAA,AAACC,AAAUjB,AACX,AAACkB,AAAIC;;AAE/B,AAAA,AAAMC;AAAN,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA","names":["exfn.helpers/get-source-line-numbers","source","cljs.core.reduce","p__29760","map__29766","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","cur","line-nos","acc","i","cljs.core._EQ_","clojure.string/starts-with?","cljs.core.assoc","cljs.core.update","cljs.core/inc","clojure.string.split","cljs.core.map","clojure.string/trim","exfn.helpers/get-supported-instructions"],"sourcesContent":["(ns exfn.helpers\r\n  (:require [clojure.string :as str]))\r\n\r\n(defn get-source-line-numbers [source]\r\n  (:line-nos (reduce (fn [{:keys [cur line-nos] :as acc} i]\r\n                       (if (or (= \"\" i) (clojure.string/starts-with? i \";\"))\r\n                         (assoc acc :line-nos (str line-nos \"\\n\"))\r\n                         (-> acc\r\n                             (assoc :line-nos (str line-nos cur \"\\n\"))\r\n                             (update :cur inc))))\r\n                     {:cur 0 :line-nos \"\"}\r\n                     (->> (str/split source #\"\\r?\\n\" -1)\r\n                          (map str/trim)))))\r\n\r\n(defn get-supported-instructions []\r\n  [{:instruction \"mov\"\r\n    :example      \"mov :a :b\"\r\n    :description  \"moves b (number or register) into register :a\"}\r\n   {:instruction \"add\"\r\n    :example      \"add :a :b\"\r\n    :description  \"a + b (numbers or registers), result goes into :a\"}\r\n   {:instruction \"sub\"\r\n    :example      \"sub :a :b\"\r\n    :description  \"a - b (numbers or registers), result goes into :a\"}\r\n   {:instruction \"mul\"\r\n    :example      \"mul :a :b\"\r\n    :description  \"a * b (numbers or registers), result goes into :a\"}\r\n   {:instruction \"div\"\r\n    :example      \"div :a :b\"\r\n    :description  \"a / b (numbers or registers), result goes into :a\"}\r\n   {:instruction \"and\"\r\n    :example      \"and :a :b\"\r\n    :description  \"a \u2227 b (numbers or registers), result goes into :a\"}\r\n   {:instruction \"or\"\r\n    :example      \"or :a :b\"\r\n    :description  \"a \u2228 b (numbers or registers), result goes into :a\"}\r\n   {:instruction \"xor\"\r\n    :example      \"xor :a :b\"\r\n    :description  \"a \u2295 b (numbers or registers), result goes into :a\"}\r\n   {:instruction \"dec\"\r\n    :example      \"dec :a\"\r\n    :description  \"Decrements the register :a by one\"}\r\n   {:instruction \"inc\"\r\n    :example      \"inc :a\"\r\n    :description  \"Increments the register :a by one\"}\r\n   {:instruction \"jnz\"\r\n    :example      \"jnz :x :y\"\r\n    :description  \"jumps y (number or register) instructions (positive or negative) if x (number or register) is not zero.\"}\r\n   {:instruction \"label\"\r\n    :example      \"foo:\"\r\n    :description  \"Creates a label foo: that can be used by jmp or call instructions. If encountered as an instruction it is ignored.\"}\r\n   {:instruction \"jmp\"\r\n    :example      \"jmp foo\"\r\n    :description  \"Moves the execution pointer to the label foo.\"}\r\n   {:instruction \"nop\"\r\n    :example      \"nop\"\r\n    :description  \"Does nothing.\"}\r\n   {:instruction \"cmp\"\r\n    :example      \"cmp :x :y\"\r\n    :description  \"compares x and y and stores the result in the internal register :cmp, result will either be x < y, x = y, x > y.\"}\r\n   {:instruction  \"jne\"\r\n    :example      \"jne foo\"\r\n    :description  \"jumps to the label foo if the result of the previous cmp call was that x /= y\"}\r\n   {:instruction  \"jg\"\r\n    :example      \"jg foo\"\r\n    :description  \"jumps to the label foo if the result of the previous cmp call was that x > y\"}\r\n   {:instruction  \"jge\"\r\n    :example      \"jge foo\"\r\n    :description  \"jumps to the label foo if the result of the previous cmp call was that x >= y\"}\r\n   {:instruction  \"je\"\r\n    :example      \"je foo\"\r\n    :description  \"jumps to the label foo if the result of the previous cmp call was that x = y\"}\r\n   {:instruction  \"jle\"\r\n    :example      \"jle foo\"\r\n    :description  \"jumps to the label foo if the result of the previous cmp call was that x <= y\"}\r\n   {:instruction  \"jl\"\r\n    :example      \"jl foo\"\r\n    :description  \"jumps to the label foo if the result of the previous cmp call was that x < y\"}\r\n   {:instruction  \"call\"\r\n    :example      \"call foo\"\r\n    :description  \"Moves the execution pointer to the label foo, pushes the current execution pointer onto the EIP stack so that it can be returned to by a ret instruction.\"}\r\n   {:instruction \"ret\"\r\n    :example      \"ret\"\r\n    :description  \"returns execution to the top execution pointer on the execution pointer stack. Results in popping eip stack.\"}\r\n   {:instruction \"end\"\r\n    :example      \"end\"\r\n    :description  \"terminates the program.\"}\r\n   {:instruction \"pop\"\r\n    :example      \"pop :x\"\r\n    :description  \"Pops the top value off the stack into register x\"}\r\n   {:instruction \"push\"\r\n    :example      \"push :x\"\r\n    :description  \"Pushes x (value or register) onto the stack\"}\r\n   {:instruction \"cat\"\r\n    :example      \"cat :x y\"\r\n    :description  \"Concatents the string in register x with the string y (where y is a register or literal string)\"}\r\n   {:instruction \"comments\"\r\n    :example      \"; foo\"\r\n    :description  \"Comments are ignored, can be on own line or trailing, e.g. mov a b ; moves b into a\"}])"]}