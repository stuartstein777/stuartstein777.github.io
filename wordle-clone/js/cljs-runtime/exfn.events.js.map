{"version":3,"sources":["exfn/events.cljs"],"mappings":"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","names":["re_frame.core.reg_event_db","_","exfn.words/words","cljs.core/shuffle","cljs.core/first","clojure.string/upper-case","exfn.events/clamp","n","x__4217__auto__","y__4218__auto__","x__4214__auto__","y__4215__auto__","exfn.events/valid-key?","key","fexpr__29946","cljs.core/set","p__29947","map__29948","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","cljs.core.get","exfn.events/set-game-over","word","current-row","db","guess","cljs.core._EQ_","cljs.core.assoc","p__29952","map__29953","guessed-letters","exfn.events/process-key","guesses","current-col","game-state","pred__29955","expr__29956","cljs.core/=","cljs.core.update","cljs.core/assoc-in","p1__29950#","cljs.core.get_in","cljs.core/vals","cljs.core/str","G__29958","clojure.string/lower-case","cljs.core/inc","clojure.set.union","and__4115__auto__","cljs.core.not_EQ_","p1__29951#","p__29959","vec__29960","cljs.core.nth","p__29963","vec__29964","G__29968","G__29969","fexpr__29967","cljs.core/char"],"sourcesContent":["(ns exfn.events\n  (:require [re-frame.core :as rf]\n            [exfn.logic :as bf]\n            [clojure.set :as set]\n            [clojure.string :as str]\n            [exfn.words :as w]\n            [re-pressed.core :as rp]))\n\n(rf/reg-event-db\n :initialize\n (fn [_ _]\n   {:word    (-> w/words\n                 shuffle\n                 first\n                 str/upper-case)\n    \n    :guesses {1 {1 \"\", 2 \"\", 3 \"\", 4 \"\", 5 \"\"}\n              2 {1 \"\", 2 \"\", 3 \"\", 4 \"\", 5 \"\"}\n              3 {1 \"\", 2 \"\", 3 \"\", 4 \"\", 5 \"\"}\n              4 {1 \"\", 2 \"\", 3 \"\", 4 \"\", 5 \"\"}\n              5 {1 \"\", 2 \"\", 3 \"\", 4 \"\", 5 \"\"}\n              6 {1 \"\", 2 \"\", 3 \"\", 4 \"\", 5 \"\"}}\n    \n    :guessed-letters #{}\n    :current-row 1\n    :current-col 0\n    :error false\n    :game-state :playing}))\n\n(defn clamp [n]\n  (min (max n 0) 5))\n\n(defn valid-key? [key]\n  ((set \"ABCDEFGHJIKLMNOPQRSTUVWXYZ\") key))\n\n(defn set-game-over [{:keys [word current-row] :as db} guess]\n  (cond \n    (= word guess)\n    (assoc db :game-state :won)\n    \n    (= current-row 7)\n    (assoc db :game-state :lost)\n    \n    :else\n    (assoc db :game-state :playing)))\n\n(defn process-key\n  [{:keys [guesses current-row current-col :guessed-letters game-state] :as db} key]\n  (condp = key\n    \"DEL\" (if (>= current-col 1)\n            (-> db\n                (update :guesses assoc-in [current-row current-col] \"\")\n                (update :current-col #(clamp (dec %)))\n                (assoc :error false))\n            db)\n\n    \"ENTER\" (if (= 5 current-col)\n              (let [guess (->> (get-in guesses [current-row])\n                               vals\n                               (apply str))]\n                (if (w/words (str/lower-case guess))\n                  (-> db\n                      (assoc :error false)\n                      (update :current-row inc)\n                      (assoc :guessed-letters (set/union guessed-letters (set guess)))\n                      (assoc :current-col 0)\n                      (set-game-over guess))\n                  (assoc db :error true)))\n              db)\n\n    (if (and (= game-state :playing) (valid-key? key) (not= current-col 5))\n      (-> db\n          (update :guesses assoc-in [current-row (inc current-col)] key)\n          (update :current-col #(clamp (inc %)))\n          (assoc :error false))\n      db)))\n\n(rf/reg-event-db\n :clicked\n (fn [db [_ key]]\n   (process-key db key)))\n\n(rf/reg-event-db\n :key-pressed\n (fn [db [_ key]]\n   (process-key db ({13 \"ENTER\", 8 \"DEL\"} key (char key)))))"]}