{"version":3,"sources":["exfn/gamelogic.cljs"],"mappings":"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","names":["exfn.gamelogic/board-squares","exfn.gamelogic/winner?","board","win-states","flattened","cljs.core.apply","cljs.core/concat","pnth","cljs.core.partial","cljs.core/nth","cljs.core.mapv","win-state","cljs.core/some","cljs.core/first","exfn.gamelogic/no-more-moves?","p__38900","vec__38901","cljs.core.nth","exfn.gamelogic/get-square-to-play","b","s","cljs.core.map","cljs.core/vector","cljs.core.filter","p__38904","vec__38905","a","_","cljs.core._EQ_","cljs.core/second","exfn.gamelogic/find-wins","player","p__38908","vec__38909","exfn.gamelogic/find-fork","squares","cljs.core/seq","vec__38915","r","c","cljs.core.prn","cljs.core.get_in","cljs.core/assoc-in","cljs.core/count","cljs.core/rest","exfn.gamelogic/win?","square","Math/floor","cljs.core/mod","exfn.gamelogic/random-cpu-move","f","cljs.core/shuffle","exfn.gamelogic/play-center-if-possible","exfn.gamelogic/cpu-move","p","or__4126__auto__","fexpr__38919"],"sourcesContent":["(ns exfn.gamelogic)\n\n(def board-squares [[0 0] [0 1] [0 2]\n                  [1 0] [1 1] [1 2]\n                  [2 0] [2 1] [2 2]])\n\n(defn winner? [board]\n  (let [win-states [[0 1 2] [3 4 5] [6 7 8]\n                    [0 3 6] [1 4 7] [2 5 8]\n                    [2 4 6] [0 4 8]]\n        flattened (apply concat board)\n        pnth (partial nth flattened)]\n    (->> win-states\n         (mapv (fn [win-state] (mapv pnth win-state)))\n         (some #{[:x :x :x] [:o :o :o]})\n         (first))))\n\n(defn no-more-moves? [board]\n  (->> board\n       (apply concat)\n       (some #{:_})\n       nil?))\n\n;; [[:o :o :_] [2 5 8]] => 8\n(defn get-square-to-play [[b s]]\n  (->> (map vector b s)\n       (filter (fn [[a _]] (= a :_)))\n       (first)\n       (second)))\n\n(defn find-wins [board player]\n  (let [win-states [[0 1 2] [3 4 5] [6 7 8]\n                    [0 3 6] [1 4 7] [2 5 8]\n                    [2 4 6] [0 4 8]]\n        flattened (apply concat board)\n        pnth (partial nth flattened)]\n    (->> win-states\n         (mapv (fn [win-state]\n                 [(mapv pnth win-state)\n                  win-state]))\n         (filter (fn [[b _]]\n                   (some #{[player :_ player]\n                           [:_ player player]\n                           [player player :_]} [b]))))))\n\n(defn find-fork [board player]\n (loop [squares [[0 0] [0 1] [0 2]\n                 [1 0] [1 1] [1 2]\n                 [2 0] [2 1] [2 2]]]\n   (if (seq squares)\n     (let [[r c] (first squares)]\n       (prn \"trying \" [r c])\n       (if (and (= :_ (get-in board [r c]))\n                (>= (-> (assoc-in board [r c] player)\n                        (find-wins player)\n                        count) 2))\n         (do\n           (prn \"found fork @ \" [r c])\n           [r c])\n         (recur (rest squares))))\n     nil)))\n\n(defn win? [board player]\n  (let [square (->> (find-wins board player)\n                    (first)\n                    (get-square-to-play))]\n    (when square\n      [(Math/floor (/ square 3)) (mod square 3)])))\n\n(defn random-cpu-move [board]\n  (let [squares [[0 0] [0 1] [0 2]\n                 [1 0] [1 1] [1 2]\n                 [2 0] [2 1] [2 2]]]\n    (->> (filter (fn [f] (= :_ (get-in board f))) squares)\n         (shuffle)\n         (first))))\n\n(defn play-center-if-possible [board]\n  (if (= :_ (get-in board [1 1]))\n    [1 1]\n    nil))\n\n;; todo add tests\n;; need to find a fork, but then find a way to defend it\n;; that makes 2 in a row to force a defend.\n;; find-forks inverted player\n;; then try all squares (except fork square), see if any \n;; make 2 in a row\n;; blocking the win cant be the fork square.\n\n;; cond -> win, block, fork, block fork, play center,\n;;         oppo corner, empty corner, empty sidfe.\n(defn cpu-move [b p]\n  (or (win? b p)\n      (win? b ({:x :o :o :x} p))\n      (find-fork b p)\n      (play-center-if-possible b)\n      (random-cpu-move b)))\n\n;; find-fork returns [x y], win? returns n\n\n(comment\n\n  (let [board [[:o :x :_]\n               [:_ :o :x]\n               [:_ :_ :x]]]\n    (or #_(win? board :o)\n        #_(win? board :x)\n        (find-fork board :o)\n        #_(find-fork board :x)\n        #_(random-cpu-move board)))\n  \n  \n  )"]}